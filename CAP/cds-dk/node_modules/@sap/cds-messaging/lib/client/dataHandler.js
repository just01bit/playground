const { resolve } = require('../utils/thenable')
const { commit, rollback } = require('../utils/commitAndRollback')

class Message {
  constructor (event, payload, raw, topic) {
    this.event = event || topic
    this.data = payload.data
    this.headers = Object.assign({}, payload)
    delete this.headers.data
    Object.defineProperty(this, '_', { value: raw })
  }

  reject (arg) {
    // TODO: Clarify if error is needed (maybe to be alligned with REST/OData service handlers)
    throw typeof arg === 'string' ? new Error(arg) : arg
  }
}

const dataHandler = (onHandlers, errHandlers, base) => raw => {
  const { subject: topic } = raw.source.properties
  if (!topic) {
    return
  }

  const [, entity, event] = topic.match(new RegExp(`^${base}(?:\\/([^/]*))?\\/([^/]*)$`)) || []

  const matchedHandlers = onHandlers.filter(
    each =>
      (event && entity && (each.event === '*' || each.event === event) && each.entity === entity) ||
      (event && !entity && !each.entity && each.event === event) ||
      each.topic === topic
  )

  if (!matchedHandlers.length) {
    raw.done()
    return
  }

  let payload
  try {
    payload = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(Buffer.concat(raw.payload.chunks))))
  } catch (err) {
    return raw.done()
  }
  const msg = new Message(event, payload, raw, topic)

  return matchedHandlers
    .reduce((chain, handler) => chain.then(() => handler.handler(msg)), resolve())
    .then(async () => {
      await commit(msg)
      raw.done()
    })
    .catch(async err => {
      console.error(err)
      try {
        await errHandlers.reduce((chain, errHandler) => chain.then(() => errHandler(err)), resolve())
      } catch (e) {}
      raw.done()
      return rollback(msg)
    })
}
module.exports = dataHandler
