/**
 * Transaction to encapsulate operations on a data source which should be executed as an atomic unit of work.
 */
module.exports = class Transaction {
  /**
   * Creates a transaction for a given connection service and a specific context.
   * @param {Object} service - Session allowing to acquire and manage data source clients
   * @param {Object} context - Object to which the transaction is assigned. Most frequently it is the req argument
   * in an event handler; in that case the transaction will be automatically. If omitted, a new transaction will be
   * started, which will not be committed and ended automatically.
   */
  constructor (service, context) {
    Object.assign(this, { _service: service, _context: context })
    for (const [, each] of service.options.packages) {
      Object.assign(this, each.serviceFunctions)
      Object.assign(this, each.httpFunctions)
    }
  }

  run (query, values) {
    return _run('run', this, query, values)
  }
  foreach (query, values, callback) {
    return _run('foreach', this, query, values, callback)
  }
  commit (ignoreReleaseError) {
    return _end('commit', this, ignoreReleaseError)
  }
  rollback (ignoreReleaseError) {
    return _end('rollback', this, ignoreReleaseError)
  }
}

const followProjection = require('../util/followProjection')
const MODEL = Symbol.for('sap.cds.model') // Support for legacy push down of model

/**
 * Helper for tx.run and tx.foreach
 */
async function _run (op, tx, query, ...etc) {
  // acquire a connection from the pool if first _run of transaction
  if (!tx.client) {
    /*
     * make tx.client a promise for immediate effect on parallel _run's
     * (i.e., second _run will wait on client in if statement below)
     * that resolves with the resoliution of client.begin
     */
    tx.client = tx._service.acquire(tx._context).then(async c => {
      await c.begin()
      c.setCSN(tx._context[MODEL] || tx._service.model)
      c.setContext(tx._context)
      return c
    })
  }

  // wait till begin is done (log error and pass up)
  if ('then' in tx.client) {
    try {
      tx.client = await tx.client
    } catch (err) {
      if (process.env.NODE_ENV !== 'production') {
        console.error(err)
      }
      throw err
    }
  }

  // bulk run a set of queries
  if (Array.isArray(query)) return Promise.all(query.map(q => _run(op, tx, q)))
  query = followProjection(query, tx._service)

  // finally run single queries
  return tx.client[op](query, ...etc)
}

/**
 * Helper for tx.commit and tx.rollback
 */
async function _end (op, tx, ignoreReleaseError) {
  let client = tx.client

  if (!client) {
    if (ignoreReleaseError) return
    else throw new Error(`Cannot ${op}: client not found`)
  } else if ('then' in client) client = await client

  // remove no longer needed connection
  tx._context._.shared.connections.delete(tx._service)
  delete tx.client

  try {
    // REVISIT: Why is the session destroyed when the commit fails?
    await client[op]()
    await tx._service.release(client)
  } catch (err) {
    await tx._service.destroy(client)
    throw err
  }
}
