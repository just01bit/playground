const {
  messages: { DB_CONNECTION_MISSING }
} = require('../utils/constants')
const getColumns = require('../utils/columns')
const { getSelectCQN, checkNotNull } = require('../utils/handlerUtils')
const { resolveCqnIfView, getTargetData } = require('../utils/defaultHandlers')
const cds = require('../../cds')

const _getInsertCQN = context => {
  const { target, data } = getTargetData(context.target, Object.assign({}, context.data))

  return context.statements.INSERT.into(target).entries([data])
}

const _containsChanges = async context => {
  const diffKeys = Object.keys(await context.diff())
  const entityKeys = Object.keys(context.target.keys)
  return diffKeys.length !== entityKeys.length
}

/*
 * read data as on db and return
 */
const _getResult = async context => {
  const cols = Object.keys(context.target.elements).filter(
    k => context.target.elements[k].type !== 'cds.Association' && context.target.elements[k].type !== 'cds.Composition'
  )
  const data = await context.run(getSelectCQN(context, cols))

  return Array.isArray(data) && data.length > 0 ? data[0] : {}
}

/*
 * fix missing etag in context.query.cqn.data, if necessary
 */
const _fixEtagIfNecessary = context => {
  try {
    const etagCol = Object.values(context.target.elements).find(ele => ele['@odata.etag'])
    if (etagCol && context.data[etagCol.name] && !context.query.cqn.data[etagCol.name]) {
      context.query.cqn.data[etagCol.name] = { val: context.data[etagCol.name] }
    }
  } catch (e) {
    // nothing to do
  }
}

/**
 * Generic Handler for UPDATE requests.
 * In case of success it returns the updated entry.
 * If the entry to be updated does not exist, a new entry is created.
 *
 * @param context - operation object, that provides error, continuation and other functions as well as information
 * regarding the current operation.
 * @alias module:handlers.onUpdate
 */
const onUpdate = () => async context => {
  if (!context.run) {
    context.log.warn(DB_CONNECTION_MISSING)
    return context.data
  }

  const partialPersistentState = context && context._ && context._.partialPersistentState
  const neededColumns = getColumns(context.target, true)
  const checkExistCQN = getSelectCQN(context, neededColumns)

  let result
  if (partialPersistentState) {
    result = partialPersistentState
  } else {
    result = checkExistCQN ? await context.run(checkExistCQN) : []
  }

  /*
   * UPDATE or UPSERT
   *
   * if no key information given, or entry is not available -> create a new one
   * else if changes -> update
   * else -> do nothing
   */
  if (result.length === 0) {
    // reject with error if upsert not allowed
    if (cds.env && cds.env.runtime && cds.env.runtime.allow_upsert === false) {
      context.reject(404)
      return
    }

    if (checkNotNull(context)) {
      return
    }

    await context.run(_getInsertCQN(context))
  } else if (await _containsChanges(context)) {
    // Store for auditing
    context._oldData = result[0]

    // REVISIT: remove when CDSNODE-1852 is fixed
    _fixEtagIfNecessary(context)

    const count = await context.run(resolveCqnIfView(context))

    // reject with error if query update fails (not authorized)
    if (count === 0) {
      context.reject(403)
      return
    }
  }

  return _getResult(context)
}

module.exports = onUpdate
