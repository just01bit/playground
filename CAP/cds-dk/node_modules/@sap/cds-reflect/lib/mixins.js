/**
 * Add aspects to a given object.
 *
 *    extend (Object.prototype) .with (class {
 *       get foo() { return ... }
 *       bar() {...}
 *    }.prototype)
 *
 * @type <T>(t:T) => ({
 *  with <X> (x:X): ( T & X )
 *  with <X,Y> (x:X, y:Y): ( T & X & Y )
 *  with <X,Y,Z> (x:X, y:Y, z:Z): ( T & X & Y & Z )
 * })
 */
const extend = exports.extend = (target) => ({
    with (...aspects) {
        const excludes = _excludes [typeof target] || {}
        for (let each of aspects) {
            for (let p of Reflect.ownKeys(each)) {
                if (p in excludes) continue
                Reflect.defineProperty (target, p, Reflect.getOwnPropertyDescriptor (each,p))
            }
            if (is_class(target) && is_class(each)) {
                extend(target.prototype) .with (each.prototype)
            }
        }
        return target
    }
})

const _excludes = {
    function: { name:1, length:2, arguments:3, caller:4, prototype:5 },
    object: { constructor:1 },
}


/**
 * Equip a given facade object with getters for lazy-loading modules instead
 * of static requires. There are two usage options:
 *
 * 1. Lazify a facade object:
 * @example
 * const facade = lazify ({
 *  sub: lazy => require ('./sub-module')
 * })
 *
 * 2. Lazify a module:
 * @example
 * require = lazify (module) //> turns require into a lazy one
 * const facade = module.exports = {
 *  sub: require ('./sub-module')
 * })
 *
 * Option 2 allows to keep tools support for cross-navigation, e.g. in VSCode.
 * In both cases, the first usage of `facade.sub` will load the sub module
 * using standard Node.js's `module.require` functions.
 *
 * @type <T>(o:T) => o
 */
exports.lazify = (o) => {
    if (o.constructor === module.constructor) return lazify_module(o)
    for (let p of Reflect.ownKeys(o)) {
        const pd = Reflect.getOwnPropertyDescriptor(o,p)
        if (is_lazy(pd.value)) Reflect.defineProperty (o,p, {
            set(v) { Reflect.defineProperty (this,p,{ value:v, __proto__:pd }) },
            get() { return this[p] = pd.value (p,this) },
            configurable:true
        })
    }
    return o
}

const lazify_module = (module) => {
    extend (module) .with ({ set exports (all) {
        extend (module) .with ({ exports: exports.lazify(all) })
    }})
    return id => lazy => module.require(id)
}

const is_lazy = x => typeof x === 'function' && /^\(?lazy[,)\t =]/.test(x)
const is_class = x => typeof x === 'function' && /^class\b/.test(x)
