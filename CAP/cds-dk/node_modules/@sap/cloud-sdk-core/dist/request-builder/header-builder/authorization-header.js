"use strict";
/*!
 * Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var cloud_sdk_util_1 = require("@sap/cloud-sdk-util");
var rambda_1 = require("rambda");
var scp_cf_1 = require("../../scp-cf");
var logger = cloud_sdk_util_1.createLogger({
    package: 'core',
    messageContext: 'authorization-header'
});
/**
 * Adds authorization headers for a given ODataRequest to existing headers.
 *
 * @param request an ODataRequest.
 * @param headers The headers that should be added to.
 * @returns The provided headers with the new authorization headers.
 */
function addAuthorizationHeader(request, headers) {
    if (authorizationHeaderFromCustomHeaders(request)) {
        return Promise.resolve(assocAuthHeader(headers)(authorizationHeaderFromCustomHeaders(request)));
    }
    if (request.needsAuthentication()) {
        if (!request.destination) {
            throw Error('The request destination is undefined.');
        }
        return exports.buildAndAddAuthorizationHeader(request.destination)(headers);
    }
    return Promise.resolve(headers);
}
exports.addAuthorizationHeader = addAuthorizationHeader;
/**
 * Adds authorization headers for a given destination to existing headers.
 *
 * @param destination A destination.
 * @param headers The headers that should be added to.
 * @returns The provided headers with the new authorization headers.
 */
exports.buildAndAddAuthorizationHeader = function (destination) { return function (headers) {
    if (destination.authentication === 'NoAuthentication' || destination.authentication === 'ClientCertificateAuthentication') {
        return Promise.resolve(headers);
    }
    else if (!destination.authentication) {
        logger.warn('No authentication type is specified on the destination! Assuming "NoAuthentication".');
        return Promise.resolve(headers);
    }
    return buildAuthHeader(destination).then(assocAuthHeader(headers));
}; };
var authorizationHeaderFromCustomHeaders = function (request) {
    return rambda_1.path(['config', 'customHeaders', 'authorization'], request) || rambda_1.path(['config', 'customHeaders', 'Authorization'], request);
};
var assocAuthHeader = function (headers) { return function (authHeader) { return rambda_1.assoc('authorization', authHeader)(headers); }; };
var buildAuthHeader = function (destination) {
    switch (destination.authentication) {
        case 'OAuth2SAMLBearerAssertion':
            if (!destination.authTokens) {
                throw new Error('The auth token is null.');
            }
            return Promise.resolve(headerFromTokens(destination.authTokens));
        case 'OAuth2ClientCredentials':
            return headerFromOAuth2ClientCredentialsDestination(destination);
        case 'BasicAuthentication':
            return Promise.resolve(headerFromBasicAuthDestination(destination));
        default:
            throw new Error('Failed to build authorization header for the given destination. Make sure to either correctly configure your destination for principal propagation, provide both a username and a password or select "NoAuthentication" in your destination configuration.');
    }
};
var throwAllTokensErrored = function (authTokens) {
    throw new Error([
        'The destination tried to provide authorization tokens but errored in all cases. This is most likely due to misconfiguration.',
        'Original error messages:'
    ].concat(rambda_1.map(function (token) { return token.error; }, authTokens)).join('\n'));
};
var headerFromOAuth2ClientCredentialsDestination = function (destination) {
    return scp_cf_1.getOAuth2ClientCredentialsToken(destination)
        .then(function (resp) { return "Bearer " + resp.access_token; })
        .catch(function (error) { return Promise.reject(cloud_sdk_util_1.errorWithCause('Request for "OAuth2ClientCredentials" authentication access token failed or denied.', error)); });
};
var headerFromAuthToken = function (token) { return token.type + " " + token.value; };
// using pipe led to wrong type errors
var headerFromTokens = function (authTokens) {
    var usableTokens = rambda_1.filter(function (token) { return !token.error; }, authTokens);
    if (authTokens === null) {
        throw new Error('AuthenticationType is "OAuth2SAMLBearerAssertion", but no AuthTokens could be fetched from the destination service!');
    }
    if (rambda_1.isEmpty(usableTokens)) {
        throwAllTokensErrored(authTokens);
    }
    rambda_1.ifElse(rambda_1.isEmpty, throwAllTokensErrored, rambda_1.identity)(usableTokens);
    var usableToken = rambda_1.head(usableTokens);
    if (!usableToken) {
        throw new Error("No usable tokens are found in the " + usableTokens);
    }
    return headerFromAuthToken(usableToken);
};
var headerFromBasicAuthDestination = function (destination) {
    if (rambda_1.isNil(destination.username) || rambda_1.isNil(destination.password)) {
        throw new Error('AuthenticationType is "BasicAuthentication", but "username" and/or "password" are missing!');
    }
    return basicHeader(destination.username, destination.password);
};
function basicHeader(username, password) {
    return "Basic " + Buffer.from(username + ":" + password).toString('base64');
}
exports.basicHeader = basicHeader;
//# sourceMappingURL=authorization-header.js.map