const COMMAND_URL_SUFFIX = 'activate';
const I18N_WHITELIST = ['.properties', '.csv'];

const os = require('os');
const got = require('got');
const path = require('path');
const BaseCommand = require('./base_command');
const clientLog = require('./helper/logging');
const fs = require('fs-extra');
const fsHelper = require('./helper/fs_helper');

class Apply extends BaseCommand {

    static get COMMAND_URL_SUFFIX() { return COMMAND_URL_SUFFIX; };

    static async run(sources, folder, { subdomain, to: url, passcode, username, password, undeploy, wsdl } = {}) {


        if (url && !url.endsWith('/')) {
            url = url + '/';
        }

        const postOptions = {
            method: 'POST',
            json: true
        };

        try {
            let projectFolder = Apply.getProjectFolder(folder);

            if (!await Apply.checkProject(projectFolder)) {
                throw new Error(projectFolder + ' is not a valid extension project');
            }

            const projectSettings = await Apply.getProjectSettings(projectFolder, url, subdomain, !username); // no subdomain change for activate

            try {
                // merge commandParameters
                const optionsWithAuth = await Apply.determineAndAddAuthentication(projectSettings, postOptions, {
                    passcode,
                    username,
                    password
                });

                clientLog.log(os.EOL + os.EOL + 'Activating extension');
                clientLog.log('Using url: ' + projectSettings.url);
                clientLog.log('From folder: ' + projectSettings.folder);
                clientLog.log('Undeploy: ' + !!undeploy);

                await Apply.runApply(sources, projectSettings.folder, optionsWithAuth, { to: projectSettings.url, undeploy });
                if (wsdl) {
                    await Apply.runCustomFileUpload(projectSettings.url, projectFolder, postOptions);
                }
            } catch (error) {
                await Apply.handleHttpError(error, projectSettings.folder);
            }
        } catch (mainError) {
            clientLog.error(mainError, mainError.message);
        }
    }

    static async collectExtensionFiles(compile, cds, projectFolder) {

        const absoluteFolder = projectFolder;
        const dbFolder = path.join(absoluteFolder, 'db');
        const srvFolder = path.join(absoluteFolder, 'srv');

        const resolvedPathDb = cds.resolve(dbFolder, { root: dbFolder });
        const resolvedPathSrv = cds.resolve(srvFolder, { root: srvFolder });

        let resolvedPaths = [];
        if (resolvedPathSrv) {
            resolvedPaths = resolvedPaths.concat(resolvedPathSrv);
        }

        if (resolvedPathDb) {
            resolvedPaths = resolvedPaths.concat(resolvedPathDb);
        }

        let allFiles = new Map();

        if (resolvedPaths.length < 1) {
            clientLog.log('No extension files found');
            return allFiles;
        }

        const csn = await compile(resolvedPaths, projectFolder);

        const filteredSources = csn._sources.filter((entry) => {
            const unixFilename = fsHelper.fixFileName(entry);
            if (!/.*node_modules\/_base\/.*/.test(unixFilename)) {
                return true;
            } else {
                return false;
            }
        });

        let sourceFiles = await fsHelper.collectFileContent(filteredSources, projectFolder);
        allFiles = new Map([...allFiles, ...sourceFiles]);

        const modelFiles4I18n = {
            _sources: filteredSources
        }

        let i18nFolders = cds.localize.folders4(modelFiles4I18n);
        i18nFolders = i18nFolders.filter(i18nFolder => {
            const unixFilename = fsHelper.fixFileName(i18nFolder);
            return !(/.*node_modules\/_base\/.*/.test(unixFilename));
        });

        i18nFolders.forEach(async(folder) => {
            let i18nFiles = await fsHelper.collectFiles(projectFolder, folder, (entry) => {
                const ext = path.extname(entry);
                return I18N_WHITELIST.includes(ext);
            });
            allFiles = new Map([...allFiles, ...i18nFiles]);
        });

        try {
            const pkgJson = await fs.readFile(path.join(absoluteFolder, 'package.json'), 'utf-8');
            allFiles.set('package.json', pkgJson);
        } catch(e) {
            clientLog.log('No package.json file found');
            clientLog.error(e, 'No package.json file found');
        }

        return allFiles;
    }

    static async collectCustomFiles(projectFolder) {
        const wsdlFolder = path.join(projectFolder, 'wsdl');

        try {
            const wsdlFiles = await fsHelper.collectFiles(projectFolder, wsdlFolder);
            if (wsdlFiles.length === 0) {
                clientLog.log('No custom files found');
            }
            return wsdlFiles;
        } catch (error) {
            clientLog.error(error, error.message);
            throw new Error('No custom files found');
        }
    }

    static async runApply({ compile, cds }, projectFolder, postOptions, { to: url, undeploy, wsdl }) {

        let activationUrl = Apply.getMtxApiUrl(url, Apply.COMMAND_URL_SUFFIX);

        const allFiles = await Apply.collectExtensionFiles(compile, cds, projectFolder);

        if (allFiles.size === 0) {
            return;
        }

        const allFilesSerialized = [...allFiles];

        clientLog.log('Activating extension...');

        const body = {
            extension: allFilesSerialized,
            undeployExtension: undeploy
        };

        let extensionPostOptions = Object.assign({}, postOptions, { body });

        try {
            await got(activationUrl, extensionPostOptions);
        } catch (error) {
            let errorMessage = error;
            if (error.statusCode === 422) {
                errorMessage = error.body.error.message;
                throw new Error(errorMessage);
            }
            throw error;
        }
        clientLog.log('Extension active');
    }

    static async runCustomFileUpload(url, projectFolder, postOptions) {
        clientLog.log('Uploading custom files...');

        console.log(url);

        const customFiles = await Apply.collectCustomFiles(projectFolder);

        const customFilesSerialized = [];
        customFiles.forEach((value, key, map) => {
            customFilesSerialized.push({
                category: "wsdl",
                name: key,
                content: value
            });
        });

        const customRequestBody = { content: customFilesSerialized };

        let customPostOptions = Object.assign({}, postOptions, { body: customRequestBody });
        let customFileUrl = Apply.getMtxApiUrl(url, Apply.UPDATE_CUSTOM_FILE_URL_SUFFIX);

        try {
            await got(customFileUrl, customPostOptions);
        } catch (error) {
            let errorMessage = error;
            if (error.statusCode === 422) {
                errorMessage = error.body.error.message;
                throw new Error(errorMessage);
            }
            throw error;
        }

        clientLog.log('Custom file upload finished');
    }

}

module.exports = Apply;
