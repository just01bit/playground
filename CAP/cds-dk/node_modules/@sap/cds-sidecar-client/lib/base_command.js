const MTX_URL_PATH_PREFIX = 'mtx/v1/model/';
const CUSTOM_FILE_URL_SUFFIX = 'customTenantContent';
const UPDATE_CUSTOM_FILE_URL_SUFFIX = 'updateCustomTenantContent';

const path = require('path');
const fs = require('fs-extra');
const { URL } = require('url');
const clientLog = require('./helper/logging');
const jwtRequestHelper = require('./helper/jwt_request_helper');
const ProjectSettings = require('./helper/project_settings');
const urlHelper = require('./helper/url_helper');

class BaseCommand {

    static get CUSTOM_FILE_URL_SUFFIX() { return CUSTOM_FILE_URL_SUFFIX; };
    static get UPDATE_CUSTOM_FILE_URL_SUFFIX() { return UPDATE_CUSTOM_FILE_URL_SUFFIX; };

    static async checkProject(folder) {
        return fs.pathExists(path.join(folder, 'package.json'));
    }

    static async getToken(url, options) {
        return jwtRequestHelper.getToken(url, options);
    }

    static getProjectFolder(projectFolder, subdomain) {
        if (!projectFolder) {
            if (subdomain) {
                projectFolder = subdomain;
                clientLog.log('No directory specified. Using subdomain name as directory.')
            } else {
                projectFolder = '.';
            }
        }

        return path.resolve(projectFolder);
    }

    static getSubdomain(subdomain, appUrl) {
        if (!subdomain) {
            if (appUrl) {
                return urlHelper.getSubdomain(appUrl);
            } else {
                throw new Error('Subdomain could not be determined. Please provide subdomain or url parameter');
            }
        } else {
            return subdomain;
        }
    }

    static async storeSettings(projectFolder, projectData) {
        try {
            const ps = new ProjectSettings();
            await ps.addSettings(projectFolder, projectData);
        } catch (error) {
            clientLog.error(error, 'Could not store settings');
        }
    }

    static async loadSettings(projectFolder) {
        clientLog.debug(null, `Loading settings for project ${projectFolder}`);

        try {
            const ps = new ProjectSettings();
            return await ps.loadSettings(projectFolder);
        } catch (error) {
            clientLog.error(error, 'Could not read settings');
        }
    }

    static async deleteSettings(projectFolder) {
        try {
            const ps = new ProjectSettings();
            await ps.removeSettings(projectFolder);
        } catch (error) {
            clientLog.error(error, 'Could not access project settings');
        }
    }

    static async deleteAllSettings() {
        try {
            const ps = new ProjectSettings();
            await ps.removeAllSettings();
        } catch (error) {
            clientLog.error(error, 'Could not access project settings');
        }
    }


    static async handleHttpError(httpError, projectFolder) {
        projectFolder = path.resolve(projectFolder);
        if (httpError.name === 'HTTPError' && httpError.statusCode === 401) {
            if (httpError.body && httpError.body.error && httpError.body.passcode_url) {
                const authError = httpError.body;
                clientLog.error(httpError, `${authError.error_description}: Get valid passcode from url ${authError.passcode_url}`);
                return;
            } else {
                let storedSettings = await BaseCommand.loadSettings(projectFolder);

                if (storedSettings && storedSettings.passcode_url) {
                    clientLog.error(httpError, `Request failed. Authorization might have expired: Get valid passcode from url ${storedSettings.passcode_url}`);
                    return;
                }
            }
        }
        clientLog.error(httpError, httpError.message);
    }

    static getMtxApiUrl(url, action) {
        const parsedUrl = new URL(url);

        parsedUrl.pathname = path.join(parsedUrl.pathname, MTX_URL_PATH_PREFIX, action);

        return parsedUrl.toString();
    }

    static async getProjectSettings(folder, appUrl, subdomain, loadStoredSettings) {

        let resolvedProjectFolder = path.resolve(folder);

        let storedProjectSettings = loadStoredSettings ? await BaseCommand.loadSettings(resolvedProjectFolder) : null;

        if (storedProjectSettings) {
            if (subdomain && (subdomain !== storedProjectSettings.subdomain)) {
                throw new Error(`Subdomain ${storedProjectSettings.subdomain} stored for project differs from given subdomain ${subdomain}`);
            }
            return Object.assign(storedProjectSettings, { folder: resolvedProjectFolder });
        } else {
            clientLog.log('No stored project settings found.');

            let usedSubdomain = BaseCommand.getSubdomain(subdomain, appUrl);

            return { folder: resolvedProjectFolder, url: appUrl, subdomain: usedSubdomain };
        }
    }

    static async determineAndAddAuthentication(projectSettings, requestOptions, { passcode, username, password }) {
        let optionsWithAuth = requestOptions;
        if (!optionsWithAuth.headers) {
            optionsWithAuth.headers = {};
        }
        if (!username) {

            let token = projectSettings.token;

            if (!token || passcode) {
                clientLog.debug(null, `No authorization token found, trying to get one using passcode ${passcode}`);
                const tokenResponse = await BaseCommand.getToken(projectSettings.url, { subdomain: projectSettings.subdomain, passcode });
                token = tokenResponse.body.access_token;
                let passcode_url = tokenResponse.body.passcode_url;
                if (token) {
                    await BaseCommand.storeSettings(projectSettings.folder, { url: projectSettings.url, token, passcode_url, subdomain: projectSettings.subdomain });
                } else {
                    throw new Error('Getting authorization token failed');
                }
            }
            optionsWithAuth.headers.Authorization = 'Bearer ' + token;
        } else {
            optionsWithAuth.auth = username + ':' + password;
        }
        return optionsWithAuth;
    }

}

module.exports = BaseCommand;
