const COMMAND_URL_SUFFIX = 'content';
const CUSTOM_FILE_FOLDERS = ['wsdl'];
const DB_FOLDER = 'db';
const SRV_FOLDER = 'srv';
const TEMPLATE_FOLDER = 'tpl';

const os = require('os');
const got = require('got');
const path = require('path');
const fs = require('fs-extra');
const BaseCommand = require('./base_command');
const clientLog = require('./helper/logging');
const askBooleanQuestion = require('./helper/question').askBooleanQuestion;


class Extend extends BaseCommand {

    static get COMMAND_URL_SUFFIX() { return COMMAND_URL_SUFFIX; };

    static async storeFiles(content, targetDirectory, filter) {
        const writtenFiles = new Set();
        const filesToWrite = new Map();
        for (const [filename, filecontent] of content) {
            const filepath = path.join(targetDirectory, filename);
            if (!filter || await filter(filepath)) {
                filesToWrite.set(filepath, filecontent);
            }
        }
        for (const [filepath, content] of [...filesToWrite.entries()]) {
            fs.mkdirpSync(path.dirname(filepath));
            fs.writeFileSync(filepath, content);
            writtenFiles.add(path.relative(process.cwd(), filepath));
            Extend._logWrittenFile(path.relative(process.cwd(), filepath));
        };
        return writtenFiles;
    }

    static async storeCustomFiles(directory, customFiles) {
        let customFileMap = new Map();
        customFiles.forEach(entry => {
            if (entry.category === 'wsdl') {
                let folder = entry.name.split(path.sep)[0];
                if (CUSTOM_FILE_FOLDERS.includes(folder)) {
                    customFileMap.set(entry.name, entry.content);
                }
            }
        });
        await Extend.storeFiles([...customFileMap], directory);
    }

    static async storeTemplateFiles(templates, directory) {
        await Extend.storeFiles(templates, directory, async(filepath) => {
            if (!filepath.includes(path.join(directory, DB_FOLDER)) && !filepath.includes(path.join(directory, SRV_FOLDER))) {
                clientLog.log(`Ignoring template ${filepath}: not in ${DB_FOLDER} or ${SRV_FOLDER}`);
                return false;
            }
            return true;
        });
    }

    static async run(url, { directory, subdomain, passcode, username, password, wsdl, templates, force }) {

        clientLog.debug(null, `Run extend using url ${url} and parameters \
            ${JSON.stringify({directory, subdomain, passcode, username, password: password ? '***' : 'undefined' })}`);

        if (url && !url.endsWith('/')) {
            url = url + '/';
        }

        clientLog.log(os.EOL + os.EOL + 'Creating extension project');

        const options = {
            method: 'GET',
            json: true,
	        retry: 0
        };

        const FOLDER_EXISTS_MESSAGE = (folder) => {
            return `${folder} already contains an extension project, use another directory or use --force.` +
                '\nWhen using --force, make sure you are using a version control system (like git) to avoid data loss';
        }

        try {
            let projectFolder = Extend.getProjectFolder(directory, subdomain); // checks the subdomain dir
            let runOnExistingProject = await Extend.checkProject(projectFolder)

            if (runOnExistingProject && !(force || templates)) {
                throw new Error(FOLDER_EXISTS_MESSAGE(projectFolder));
            }

            const projectSettings = await Extend.getProjectSettings(projectFolder, url, subdomain, !username);

            try {
                clientLog.log('Using url: ' + projectSettings.url);
                clientLog.log('Using subdomain: ' + projectSettings.subdomain);
                clientLog.log('In directory: ' + projectSettings.folder);

                const optionsWithAuth = await Extend.determineAndAddAuthentication(projectSettings, options, {
                    passcode,
                    username,
                    password
                });
                await Extend.runExtend(projectSettings.url, projectSettings.folder, optionsWithAuth, runOnExistingProject, { wsdl, templates });
            } catch (error) {
                await Extend.handleHttpError(error, projectFolder);
            }
        } catch (mainError) {
            clientLog.error(mainError);
        }
    }


    static async runExtend(url, projectFolder, requestOptions, runOnExistingProject, { wsdl, templates }) {

        let extendUrl = Extend.getMtxApiUrl(url, COMMAND_URL_SUFFIX);

        const httpResponse = await got(extendUrl, requestOptions);

        let response = httpResponse.body;
        if (Array.isArray(response)) {
            response = httpResponse.body[0];
        }

        clientLog.log(os.EOL + 'Writing files to: ' + projectFolder);

        if (templates) {
            await Extend.storeTemplateFilesToTpl(response, projectFolder);
            return; // only write templates
        }

        const content = response.base.concat(response.extension);

        await Extend.storeFiles(content, projectFolder);

        await fs.mkdirp(path.join(projectFolder, DB_FOLDER));
        await fs.mkdirp(path.join(projectFolder, SRV_FOLDER));

        clientLog.log('');
        clientLog.log(`Put database extension models into the ${DB_FOLDER}-folder.`);
        clientLog.log(`Put service extension models into the ${SRV_FOLDER}-folder.`);

        if (response.templates && (response.templates.length > 0)) {
            // only write templates if there are no extensions so far
            if (!(response.extension && response.extension.length > 0)) {
                clientLog.log(`Writing template files to ${DB_FOLDER} and ${SRV_FOLDER} folder`);
                await Extend.storeTemplateFiles(response.templates, projectFolder);
            } else {
                clientLog.log('Ignoring templates because extension is already active.');
            }
        }

        if (wsdl) {

            clientLog.log('Writing custom files');

            let customFileUrl = Extend.getMtxApiUrl(url, Extend.CUSTOM_FILE_URL_SUFFIX);

            const customFileResponse = await got(customFileUrl, requestOptions);

            const customFiles = customFileResponse.body;

            await Extend.storeCustomFiles(projectFolder, customFiles);
        }
    }

    static async storeTemplateFilesToTpl(response, projectFolder) {
        if (response.templates && (response.templates.length > 0)) {
            const targetDirectory = path.join(projectFolder, TEMPLATE_FOLDER);
            const targetExists = await fs.pathExists(targetDirectory);
            if (!targetExists || await this.promptTemplateOverwrite()) {
                if (targetExists) {
                    await fs.remove(targetDirectory);
                }
                clientLog.log(`Writing template files to ${TEMPLATE_FOLDER} folder`);
                await Extend.storeTemplateFiles(response.templates, targetDirectory);
            }

        } else {
            clientLog.log('No templates available');
        }
    }

    static promptTemplateOverwrite() {
        return askBooleanQuestion(`This  will overwrite extisting templates in folder ${TEMPLATE_FOLDER}. Continue (yN)? `, false, false);
    }

    static _logWrittenFile(file) {
        clientLog.log('CREATE: ' + file);
    }

}

module.exports = Extend;
