/** @module API */

'use strict';

const prepareOptions = require('./options');
const backends = require('../backends');
const { setProp } = require('../base/model');
const alerts = require('../base/alerts');
const {
  sortMessages, messageString, CompilationError, getMessageFunction, handleMessages,
} = require('../base/messages');
const { compactModel } = require('../json/to-csn');
const { transform4odataWithCsn } = require('../transform/forOdataNew.js');

const propertyToCheck = {
  odata: 'toOdata',
};

const { cloneCsn } = require('../model/csnUtils');

const relevantGeneralOptions = [];
const relevantOdataOptions = [ 'sqlMapping', 'odataFormat' ];
const warnAboutMismatchOdata = [ 'odataVersion' ];

/**
 * Attach options and transformation name to the $meta tag
 *
 * @param {CSN} csn CSN to attach to
 * @param {string} transformation Name of the transformation - odata or hana
 * @param {NestedOptions} options Options used for the transformation
 * @param {string[]} relevantOptionNames Option names that are defining characteristics
 * @param {string[]} [optionalOptionNames=[]] Option names that should be attached as a fyi
 */
function attachTransformerCharacteristics(csn, transformation, options,
                                          relevantOptionNames, optionalOptionNames = []) {
  const relevant = {};
  const propName = propertyToCheck[transformation];
  for (const name of relevantOptionNames ) {
    if (options[propName][name] !== undefined)
      relevant[name] = options[propName][name];
  }

  for (const name of optionalOptionNames ) {
    if (options[propName][name] !== undefined)
      relevant[name] = options[propName][name];
  }

  for (const name of relevantGeneralOptions ) {
    if (options[name] !== undefined)
      relevant[name] = options[name];
  }
  if (!csn.meta)
    setProp(csn, 'meta', {});

  setProp(csn.meta, 'options', relevant);
  setProp(csn.meta, 'transformation', transformation);
}

/**
 * Sort and log the given messages to stderr.
 *
 * @param {string[]} messages Messages to display
 */
function displayMessages(messages = []) {
  sortMessages(messages).forEach(m => process.stderr.write(`${ messageString(m, false, true) }\n`));
}

/**
 * Check the characteristics of the provided, already transformed CSN
 * Report an error if they do not match with the currently requested options
 * V2 vs V4, plain vs hdbcds etc.
 *
 * @param {CSN} csn CSN to check
 * @param {NestedOptions} options Options used for the transformation - scanned top-level
 * @param {string[]} relevantOptionNames Option names that are defining characteristics
 * @param {string[]} [warnAboutMismatch=[]] Option names to warn about, but not error on
 */
function checkPreTransformedCsn(csn, options, relevantOptionNames, warnAboutMismatch) {
  if (!csn.meta) {
    // Not able to check
    return;
  }
  const message = getMessageFunction(csn, options);

  for (const name of relevantOptionNames ) {
    if (options[name] !== csn.meta.options[name])
      message('wrong-pretransformed-csn', null, null, null, 'error', `Expected pre-processed CSN to have option "${ name }" set to "${ options[name] }". Found: "${ csn.meta.options[name] }".`);
  }

  for (const name of warnAboutMismatch ) {
    if (options[name] !== csn.meta.options[name])
      message('options-mismatch-pretransformed-csn', null, null, null, 'warning', `Expected pre-processed CSN to have option "${ name }" set to "${ options[name] }". Found: "${ csn.meta.options[name] }".`);
  }

  handleMessages(csn, options);
}

/**
 * Check if the CSN was already run through the appropriate transformer
 *
 * - Currently only check for odata, as hana is not exposed
 *
 * @param {CSN} csn CSN
 * @param {string} transformation Name of the transformation
 * @returns {boolean} Return true if it is pre-transformed
 */
function isPreTransformed(csn, transformation) {
  return csn.meta && csn.meta.transformation === transformation;
}

/**
 * Get an odata-CSN without option handling.
 *
 * @param {CSN} csn Clean input CSN
 * @param {object} internalOptions processed options
 * @returns {object} Return an oData-pre-processed CSN
 */
function odataInternal(csn, internalOptions) {
  const oDataCsn = transform4odataWithCsn(csn, internalOptions);
  attachTransformerCharacteristics(oDataCsn, 'odata', internalOptions, relevantOdataOptions, warnAboutMismatchOdata);
  // FIXME: forOdataNew should correctly pass messages to options
  internalOptions.messages = oDataCsn.messages;

  // Cleanup the CSN
  delete oDataCsn.messages;
  delete oDataCsn.options;

  return oDataCsn;
}

/**
 * Return a odata-transformed CSN
 *
 * @param {CSN} csn Clean input CSN
 * @param {oDataOptions} [options={}] Options
 * @returns {oDataCSN} Return an oData-pre-processed CSN
 */
function odata(csn, options = {}) {
  const internalOptions = prepareOptions.for.odata(options);
  const result = odataInternal(csn, internalOptions);

  processMessages(internalOptions, options);

  return result;
}

/**
 * Process the given csn back to cdl.
 *
 * @param {object} csn CSN to process
 * @param {object} [externalOptions={}] Options
 * @returns {CDL} { <artifactName>: <CDL representation>, ...}
 */
function cdl(csn, externalOptions = {}) {
  const internalOptions = prepareOptions.to.cdl(externalOptions);
  const { result, options } = backends.toCdlWithCsn(cloneCsn(csn), internalOptions);

  processMessages(options, externalOptions);

  return result;
}
/**
 * Process the given CSN into SQL.
 *
 * @param {CSN} csn A clean input CSN
 * @param {sqlOptions} [options={}] Options
 * @returns {SQL[]} Array of SQL statements, tables first, views second
 */
function sql(csn, options = {}) {
  const internalOptions = prepareOptions.to.sql(options);
  const intermediateResult = backends.toSqlWithCsn(csn, internalOptions);

  processMessages(intermediateResult, options);

  return Object.values(flattenResultStructure(intermediateResult));
}

/**
 * Process the given CSN into HDI artifacts.
 *
 * @param {CSN} csn A clean input CSN
 * @param {hdiOptions} [options={}] Options
 * @returns {HDIArtifacts} { <filename>:<content>, ...}
 */
function hdi(csn, options = {}) {
  const internalOptions = prepareOptions.to.hdi(options);
  const intermediateResult = backends.toSqlWithCsn(csn, internalOptions);

  processMessages(intermediateResult, options);
  return flattenResultStructure(intermediateResult);
}
/**
 * Process the given CSN into HDBCDS artifacts.
 *
 * @param {any} csn A clean input CSN
 * @param {hdbcdsOptions} [options={}] Options
 * @returns {HDBCDS} { <filename>:<content>, ...}
 */
function hdbcds(csn, options = {}) {
  const internalOptions = prepareOptions.to.hdbcds(options);
  const intermediateResult = backends.toHanaWithCsn(csn, internalOptions);

  processMessages(intermediateResult, options);
  return flattenResultStructure(intermediateResult);
}
/**
 * Generate a edm document for the given service
 *
 * @param {CSN|oDataCSN} csn Clean input CSN or a pre-transformed CSN
 * @param {oDataOptions} [options={}] Options
 * @returns {edm} The JSON representation of the service
 */
function edm(csn, options = {}) {
  // If not provided at all, set service to undefined to trigger validation
  const internalOptions = prepareOptions.to.edm(
    options.service ? options : Object.assign({ service: undefined }, options)
  );

  const { service } = options;

  let services;
  if (isPreTransformed(csn, 'odata')) {
    checkPreTransformedCsn(csn, internalOptions, relevantOdataOptions, warnAboutMismatchOdata);
    services = backends.preparedCsnToEdm(csn, service, internalOptions);
  }
  else {
    const oDataCsn = odataInternal(csn, internalOptions);
    services = backends.preparedCsnToEdm(oDataCsn, service, internalOptions);
  }

  processMessages(internalOptions, options);
  return services;
}

edm.all = edmall;

/**
 * Generate edm documents for all services
 *
 * @param {CSN|oDataCSN} csn Clean input CSN or a pre-transformed CSN
 * @param {oDataOptions} [options={}] Options
 * @returns {edms} { <service>:<JSON representation>, ...}
 */
function edmall(csn, options = {}) {
  const internalOptions = prepareOptions.to.edm(options);
  const { error, signal } = alerts(csn, internalOptions);

  if (internalOptions.version === 'v2')
    signal(error`ODATA JSON output is not available for ODATA V2`);


  let services;

  const result = {};

  if (isPreTransformed(csn, 'odata')) {
    checkPreTransformedCsn(csn, internalOptions, relevantOdataOptions, warnAboutMismatchOdata);
    services = backends.preparedCsnToEdmAll(csn, internalOptions);
  }
  else {
    const oDataCsn = odataInternal(csn, internalOptions);
    services = backends.preparedCsnToEdmAll(oDataCsn, internalOptions);
  }

  for (const serviceName in services) {
    const lEdm = services[serviceName];
    result[serviceName] = {};
    // FIXME: Why only metadata_json - isn't this rather a 'combined_json' ? If so, rename it!
    result[serviceName] = lEdm;
  }

  processMessages(internalOptions, options);
  return result;
}
/**
 * Generate a edmx document for the given service
 *
 * @param {CSN|oDataCSN} csn Clean input CSN or a pre-transformed CSN
 * @param {oDataOptions} [options={}] Options
 * @returns {edmx} The XML representation of the service
 */
function edmx(csn, options = {}) {
  // If not provided at all, set service to undefined to trigger validation
  const internalOptions = prepareOptions.to.edmx(
    options.service ? options : Object.assign({ service: undefined }, options)
  );

  const { service } = options;

  let services;
  if (isPreTransformed(csn, 'odata')) {
    checkPreTransformedCsn(csn, internalOptions, relevantOdataOptions, warnAboutMismatchOdata);
    services = backends.preparedCsnToEdmx(csn, service, internalOptions);
  }
  else {
    const oDataCsn = odataInternal(csn, internalOptions);
    services = backends.preparedCsnToEdmx(oDataCsn, service, internalOptions);
  }

  processMessages(internalOptions, options);
  return services;
}

edmx.all = edmxall;

/**
 * Generate edmx documents for all services
 *
 * @param {CSN|oDataCSN} csn Clean input CSN or a pre-transformed CSN
 * @param {oDataOptions} [options={}] Options
 * @returns {edmxs} { <service>:<XML representation>, ...}
 */
function edmxall(csn, options = {}) {
  const internalOptions = prepareOptions.to.edmx(options);
  let services;

  const result = {};

  if (isPreTransformed(csn, 'odata')) {
    checkPreTransformedCsn(csn, internalOptions, relevantOdataOptions, warnAboutMismatchOdata);
    services = backends.preparedCsnToEdmxAll(csn, internalOptions);
  }
  else {
    const oDataCsn = odataInternal(csn, internalOptions);
    services = backends.preparedCsnToEdmxAll(oDataCsn, internalOptions);
  }

  // Create annotations and metadata once per service
  for (const serviceName in services) {
    const lEdm = services[serviceName];

    result[serviceName] = lEdm;
  }

  processMessages(internalOptions, options);
  return result;
}

/**
 * Either display the internally collected messages
 * or return them to the external collector
 *
 * @param {any} internal Object with a messages property
 * @param {any} external Object with a messages property
 */
function processMessages(internal, external) {
  if (!external.messages) {
    displayMessages(internal.messages);
  }
  else if (internal.messages) {
    // Copy all messages, without duplicates and without killing the reference
    external.messages.length = 0;
    sortMessages(internal.messages).forEach(m => external.messages.push(m));
  }
}

/**
 * Flatten the result structure to a flat map.
 *
 * Don't loop over messages.
 *
 * @param {object} toProcess { <type>: { <name>:<content>, ...}, <type>: ...}
 * @returns {object} { <name.type>:<content> }
 */
function flattenResultStructure(toProcess) {
  const result = {};
  for (const fileType of Object.keys(toProcess)) {
    if (fileType === 'messages')
      continue;
    const artifacts = toProcess[fileType];
    for (const filename of Object.keys(artifacts))
      result[`${ filename }.${ fileType }`] = artifacts[filename];
  }

  return result;
}

module.exports = {
  odata: publishCsnProcessor(odata, 'for.odata'),
  cdl: publishCsnProcessor(cdl, 'to.cdl'),
  sql: publishCsnProcessor(sql, 'to.sql'),
  hdi: publishCsnProcessor(hdi, 'to.hdi'),
  hdbcds: publishCsnProcessor(hdbcds, 'to.hdbcds'),
  edm: publishCsnProcessor(edm, 'to.edm'),
  edmx: publishCsnProcessor(edmx, 'to.edmx'),
};


/**
 * Recompile the given CSN
 *
 * @param {object} csn Input CSN to recompile to XSN
 * @param {object} options Options
 * @returns {object} XSN
 */
function recompile(csn, options) {
  /* eslint-disable global-require */
  const { augment } = require('../json/from-csn');
  const { compileSources } = require('../main');
  /* eslint-enable global-require */
  const xsn = augment(csn); // in-place
  return compileSources( { '<stdin>.csn': xsn }, options );
}

/**
 * @param {any} processor CSN processor
 * @param {string} name Name of the processor
 * @returns {any} Function that calls the processor and recompiles in case of internal errors
 */
function publishCsnProcessor( processor, name = '' ) {
  api.internal = processor;

  if (processor.all)
    api.all = publishCsnProcessor(processor.all);

  return api;

  /**
   * Function that calls the processor and recompiles in case of internal errors
   *
   * @param {object} csn CSN
   * @param {object} options Options
   * @param {any} args Any additional arguments
   * @returns {any} What ever the processor returns
   */
  function api( csn, options = {}, ...args ) {
    try {
      return processor( csn, options, ...args );
    }
    catch (err) {
      if (err instanceof CompilationError || options.testMode)
        throw err;
      // next line to be replaced by CSN parser call which reads the CSN object
      const xsn = getXsn(csn, options);
      const message = getMessageFunction( xsn, options );
      message( 'api-recompiled-csn', { filename: 'csn.json', start: { offset: 0, line: 1, column: 1 } },
               null, {}, 'Info', 'CSN input had to be recompiled' );
      return processor( compactModel(xsn), options, ...args );
    }
  }
  /**
   * Return an XSN, with some special options depending on the transformation run
   *
   * @param {any} csn CSN to augment
   * @param {any} options Options to use
   * @returns {object} XSN
   */
  function getXsn(csn, options) {
    if ([ 'to.sql', 'to.hdi', 'to.hdbcds' ].includes(name)) {
      const optionsClone = Object.assign({}, options);
      optionsClone.messages = options.messages;
      if (!optionsClone.severities)
        optionsClone.severities = {};


      optionsClone.severities['rewrite-not-supported'] = 'Error';
      optionsClone.severities['query-undefined-element'] = 'Error';
      return recompile(csn, optionsClone);
    }

    return recompile(csn, options );
  }
}


/**
 * Option format used by the old API, where they are grouped thematically.
 *
 * @typedef {object} NestedOptions
 */

/**
 * Option format used by the new API, where all options are top-level.
 *
 * @typedef {object} FlatOptions
 */

/**
 * Available SQL dialects
 *
 * @typedef {'hana' | 'sqlite' } SQLDialect
 */

/**
 * Available types of association handling
 *
 * @typedef {'assocs' | 'joins' } AssociationMode
 */

/**
 * Available naming modes
 *
 * @typedef {'plain' | 'quoted' | 'hdbcds' } NamingMode
 */

/**
 * Available oData versions
 *
 * @typedef {'v2' | 'v4' } oDataVersion
 */

/**
 * Generally available options
 *
 * @typedef {object} Options
 * @property {boolean} [beta=false] Enable experimental features - not for productive use!
 * @property {boolean} [longAutoexposed=false] Deprecated: Produce long names (with underscores) for autoexposed entities
 * @property {Map<string, number>} [severities={}] Map of message-id and severity that allows setting the severity for the given message
 * @property {Array} [messages] Allows collecting all messages in the options instead of as part of the CSN
 */

/**
 * Options available for all oData-based functions
 *
 * @typedef {object} oDataOptions
 * @property {boolean} [beta=false] Enable experimental features - not for productive use!
 * @property {boolean} [longAutoexposed=false] Deprecated: Produce long names (with underscores) for autoexposed entities
 * @property {Map<string, number>} [severities={}] Map of message-id and severity that allows setting the severity for the given message
 * @property {Array} [messages] Allows collecting all messages in the options instead of as part of the CSN
 * @property {oDataVersion} [odataVersion='v4'] Odata version to use
 * @property {NamingMode} [sqlMapping='plain'] Naming mode to use
 * @property {string} [service] If a single service is to be rendered
 */

/**
 * Options available for to.hdi
 *
 * @typedef {object} hdiOptions
 * @property {NamingMode} [sqlMapping='plain'] Naming mode to use
 * @property {SQLDialect} [sqlDialect='hana'] SQL dialect to use - hana, hanaJoins, hanaAssocs
 * @property {boolean} [beta=false] Enable experimental features - not for productive use!
 * @property {boolean} [longAutoexposed=false] Deprecated: Produce long names (with underscores) for autoexposed entities
 * @property {Map<string, number>} [severities={}] Map of message-id and severity that allows setting the severity for the given message
 * @property {Array} [messages] Allows collecting all messages in the options instead of as part of the CSN
 */

/**
 * Options available for to.hdbcds
 *
 * @typedef {object} hdbcdsOptions
 * @property {NamingMode} [sqlMapping='plain'] Naming mode to use
 * @property {SQLDialect} [sqlDialect='hana'] SQL dialect to use - hana, hanaJoins, hanaAssocs
 * @property {boolean} [beta=false] Enable experimental features - not for productive use!
 * @property {boolean} [longAutoexposed=false] Deprecated: Produce long names (with underscores) for autoexposed entities
 * @property {Map<string, number>} [severities={}] Map of message-id and severity that allows setting the severity for the given message
 * @property {Array} [messages] Allows collecting all messages in the options instead of as part of the CSN
 */

/**
 * Options available for to.sql
 *
 * @typedef {object} sqlOptions
 * @property {NamingMode} [sqlMapping='plain'] Naming mode to use
 * @property {SQLDialect} [sqlDialect='sqlite'] SQL dialect to use
 * @property {object} [magicVars] Value for the "$user.locale" variable in "sqlite" dialect
 * @property {string} [magicVars.locale] Value for the "$user.locale" in "sqlite" dialect
 * @property {string} [magicVars.user] Value for the "$user" variable in "sqlite" dialect
 * @property {boolean} [beta=false] Enable experimental features - not for productive use!
 * @property {boolean} [longAutoexposed=false] Deprecated: Produce long names (with underscores) for autoexposed entities
 * @property {Map<string, number>} [severities={}] Map of message-id and severity that allows setting the severity for the given message
 * @property {Array} [messages] Allows collecting all messages in the options instead of as part of the CSN
 */

/**
 * A fresh (just compiled, not transformed) CSN
 *
 * @typedef {object} CSN
 */

/**
 * A CSN transformed for oData - can be rendered to edm or edmx
 *
 * @typedef {CSN} oDataCSN
 */

/**
 * The CDL representation of a model
 *
 * @typedef {object} CDL
 */

/**
 * A map of { <file.hdbcds>:<content> }.
 *
 * @typedef {object} HDBCDS
 */

/**
 * A map of { <file.hdbtable/view...>:<content> }.
 *
 * @typedef {object} HDIArtifacts
 */

/**
 * An array of SQL statements, first CREATE TABLE, then CREATE VIEW.
 *
 * @typedef {string[]} SQL
 */

/**
 * The XML document representing the service.
 *
 * @typedef {object} edmx
 */

/**
 * The JSON document representing the service.
 *
 * @typedef {object} edm
 */

/**
 * A map of { <serviceName>:<XML> }.
 *
 * @typedef {object} edmxs
 */

/**
 * A map of { <serviceName>:<JSON> }.
 *
 * @typedef {object} edms
 */
