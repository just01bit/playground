'use strict';
/* eslint max-statements-per-line:off */
const { setProp } = require('../base/model');
const { forEachDefinition, forEachMemberRecursively, getUtils, cloneCsn } = require('../model/csnUtils');
const alerts = require('../base/alerts');
const edmUtils = require('./edmUtils.js')

const {
  intersect,
  validateOptions,
  foreach,
  forAll,
  isAssociationOrComposition,
  isComposition,
  isStructuredArtifact,
  isParameterizedEntityOrView,
  isActionOrFunction,
  getReferentialConstraints,
} = require('./edmUtils.js');


/*
 *  edmPreprocessor warms up the model so that it can be converted into an EDM document and
 *  contains all late & application specific model transformations
 *  that should NOT become persistent in the published CSN model but only
 *  be presented in the resulting EDM files. These late tweaks or mods can
 *  be dependent to EDM version.
 */ 

function initializeModel(csn, _options)
{
  if(_options == undefined)
    throw Error('Please debug me: initializeModel must be invoked with options');
  
  const { error, warning, info, signal } = alerts(csn);
  const {
      isStructured,
      isAssocOrComposition,
    } = getUtils(csn);


  // make sure options are complete
  let options = validateOptions(_options);

  // First attach names to all definitions in the model
  forAll(csn.definitions, (a, n) => {
    setProp (a, 'name', n);
  });

  foreach(csn.definitions, isActionOrFunction, a => {
    forAll(a.params, (p,n) => {
      setProp (p, 'name', n);
    })
  });

  // Fetch service objects
  let services = Object.keys(csn.definitions).reduce((services, artName) => {
    let art = csn.definitions[artName];
    if(art.kind === 'service' && !art.abstract) {
      services.push(art);
    }
    return services;
  }, [] );

  let serviceNames = services.map(s => s.name);
  // Link association targets and spray @odata.contained over untagged compositions
  foreach(csn.definitions, isStructuredArtifact, linkAssociationTarget);
  // Create data structures for containments
  foreach(csn.definitions, isStructuredArtifact, initializeContainments);
  // Initialize entities with parameters (add Parameter entity)
  foreach(csn.definitions, isParameterizedEntityOrView, initializeParameterizedEntityOrView);
  // Initialize structures
  foreach(csn.definitions, isStructuredArtifact, initializeStructure);
  // Initialize associations
  foreach(csn.definitions, isStructuredArtifact, initializeAssociation);
  // get constraints for associations
  foreach(csn.definitions, isStructuredArtifact, initializeConstraints);
  // create association target proxies
  foreach(csn.definitions, isStructuredArtifact, redirectDanglingAssociationsToProxyTargets);
  // decide if an entity set needs to be constructed or not
  foreach(csn.definitions, isStructuredArtifact, determineEntitySet);

  // let all doc props become @Core.Descriptions
  forEachDefinition(csn, artifact => {
    forEachMemberRecursively(artifact,
      member => {
        assignAnnotation(member, '@Core.Description', member.doc);
      }
    );
  });

  return [services, options];

  // link association target to association and add @odata.contained to compositions in V4
  function linkAssociationTarget(struct) {
    foreach(struct.elements, isAssociationOrComposition, (element, name) => {
      if (element._ignore)
        return;
      if(!element._target) {
        let target = csn.definitions[element.target];
        if(target) {
          setProp(element, '_target', target);
          // If target has parameters, xref assoc at target for redirection
          if(isParameterizedEntityOrView(target)) {
            if(!target.$sources) {
              setProp(target, '$sources', Object.create(null));
            }
            target.$sources[struct.name + '.' + name] = element;
          }
        }
        else {
          signal(error`Target ${element.target} cannot be found in the model`, [ 'definitions', struct.name, 'elements', element.name ]);
        }
      }
      // in V4 tag all compositions to be containments
      // TOOD: remove betaMode once odataContainment option is finalized
      if(options.betaMode &&
         options.odataContainment &&
         options.isV4() &&
         isComposition(element) &&
         element['@odata.contained'] === undefined) {
        element['@odata.contained'] = true;
      }
    });
  }

  // Perform checks and add attributes for "contained" sub-entities:
  // - A container is recognized by having an association/composition annotated with '@odata.contained'.
  // - All targets of such associations ("containees") are marked with a property
  //   '_containerEntity: []', having as value an array of container names (i.e. of entities
  //   that have a '@odata.contained' association pointing to the containee). Note that this
  //   may be multiple entities, possibly including the container itself.
  // - All associations in the containee pointing back to the container are marked with
  //   a boolean property '_isToContainerEntity : true', except if the association itself
  //   has the annotation '@odata.contained' (indicating the top-down link in a hierarchy).
  // - Rewrite annotations that would be assigned to the containees entity set for the
  //   non-containment rendering. If containment rendering is active, the containee has no
  //   entity set. Instead try to rewrite the annotation in such a way that it is effective
  //   on the containment navigation property.
  function initializeContainments(container) {
    foreach(container.elements, isAssociationOrComposition, (element, elementName) => {
      if (element._ignore)
        return;
      if(element['@odata.contained']) {
        // Let the containee know its container
        // (array because the contanee may contained more then once)
        let containee = element._target;
        if (!element._target._containerEntity) {
          setProp(element._target, '_containerEntity', []);
        }
        // add container only once per containee
        if (!containee._containerEntity.includes(container.name)) {
          containee._containerEntity.push(container.name);
          // Mark associations in the containee pointing to the container (i.e. to this entity)
          for (let containeeElementName in containee.elements) {
            let containeeElement = containee.elements[containeeElementName];
            if (containeeElement._target && containeeElement._target.name) {
              // If this is an association that points to a container (but is not by itself contained,
              // which would indicate the top role in a hierarchy) mark it with '_isToContainer'
              if (containeeElement._target.name == container.name && !containeeElement['@odata.contained']) {
                setProp(containeeElement, '_isToContainer', true);
              }
            }
          }
        }
        rewriteContainmentAnnotations(container, containee, elementName);
      }
    });
  }

  // Split an entity with parameters into two entity types with their entity sets,
  // one named <name>Parameter and one named <name>Type. Parameter contains Type.
  // Containment processing must take place before because it might be that this
  // artifact with parameters is already contained. In such a case the existing
  // containment chain must be propagated and reused. This requires that the
  // containment data structures must be manually added here and rewriteContainmentAnnotations()
  // must be called.
  function initializeParameterizedEntityOrView(entityCsn, entityName) {

    // Naming rules for aggregated views with parameters
    // Parameters: EntityType <ViewName>Parameters, EntitySet <ViewName>
    //             with NavigationProperty "Results" pointing to the entity set of type <ViewName>Result
    // Result:     EntityType <ViewName>Result, EntitySet <ViewName>Results

    // Naming rules for non aggregated views with parameters
    // Parameters: EntityType <ViewName>Parameters, EntitySet <ViewName>
    //             with NavigationProperty "Set" pointing to the entity set of type <ViewName>Type
    // Result:     EntityType <ViewName>Type, EntitySet <ViewName>Set
    //             Backlink Navigation Property "Parameters" to <ViewName>Parameters

    // this code can be extended for aggregated views
    let parameterEntityName = entityName + 'Parameters';
    let parameterEntitySetName = entityName;
    let originalEntityName = entityName + 'Type';
    let originalEntitySetName = entityName + 'Set';
    let parameterToOriginalAssocName = 'Set';
    let backlinkAssocName = 'Parameters';
    let hasBacklink = true;

    // Construct the parameter entity
    let parameterCsn = {
      name: parameterEntityName,
      entitySetName: parameterEntitySetName,
      kind: 'entity',
      isParamEntity:true,
      elements: Object.create(null)
    };

    // propagate containment information, if containment is recursive, use parameterCsn.name as _containerEntity
    if(entityCsn._containerEntity) {
      setProp(parameterCsn, '_containerEntity', []);
      for(let c of entityCsn._containerEntity) {
        parameterCsn._containerEntity.push((c==entityCsn.name)?parameterCsn.name:c);
      }
    }
    entityCsn._containerEntity = [ parameterCsn ];

    forAll(entityCsn.params, (p,n) => {
      let elt = cloneCsn(p);
      elt.name = n;
      delete elt.kind;
      elt.key = true; // params become primary key in parameter entity
      parameterCsn.elements[n] = elt;
    });

    // add assoc to result set, FIXME: is the cardinality correct?
    parameterCsn.elements[parameterToOriginalAssocName] = {
      '@odata.contained': true,
      name: parameterToOriginalAssocName,
      target: entityCsn.name,
      type: 'cds.Association',
      cardinality: { src: 1, min: 0, max: '*' }
    };
    setProp(parameterCsn.elements[parameterToOriginalAssocName], '_target', entityCsn);

    csn.definitions[parameterCsn.name] = parameterCsn;
    // modify the original parameter entity with backlink and new name
    csn.definitions[originalEntityName] = entityCsn;
    delete csn.definitions[entityCsn.name];
    entityCsn.name = originalEntityName;
    setProp(entityCsn, 'entitySetName', originalEntitySetName);

    // add backlink association
    if(hasBacklink) {
      entityCsn.elements[backlinkAssocName] = {
        name: backlinkAssocName,
        target: parameterCsn.name,
        type: 'cds.Association',
        on: [ { ref: [ 'Parameters', 'Set' ] }, '=', { ref: [ '$self' ] } ]
      };
      setProp(entityCsn.elements[backlinkAssocName], '_partnerCsn', []);
      setProp(entityCsn.elements[backlinkAssocName], '_target', parameterCsn);
    }
    // redirect inbound associations/compositions to the parameter entity
    /*
    TODO: Clearify in Spec meeting if this is correct
    Object.keys(entityCsn.$sources || {}).forEach(n => {
      entityCsn.$sources[n]._target = parameterCsn;
      entityCsn.$sources[n].target = parameterCsn.name;
    });
    */
    rewriteContainmentAnnotations(parameterCsn, entityCsn, parameterToOriginalAssocName);
  }

  // Initialize structured artifact (type or entity) 'struct' by doing the
  // following:
  // - attach attributes 'name', 'Name' to elements (FIXME: We currently really require both 'Name' and 'name'!)
  // - create a property 'keys' with all its primary key elements
  // - optionally add the magic ValueList association
  // - call 'initializeAssociation' for each element that has an association type
  // - attach attribute 'name' to all actions and their parameters.  
  function initializeStructure(struct) {
    let keys = Object.create(null);
    let validFrom = [], validKey = [];

    // Iterate all struct elements
    forAll(struct.elements, (element, elementName) => {
      // Attach name and Name (Name is used in function ForeignKey4(assoc))
      element.Name = elementName;
      setProp(element, 'name', elementName)
      setProp(element, '_parent', struct);

      if(element['@cds.valid.key']) {
        validKey.push(element);
      }
      if(element['@cds.valid.from']) {
        validFrom.push(element);
      }
      // Collect keys
      if (element.key) {
        keys[elementName] = element;
      }
      applyAppSpecificLateCsnTransformationOnElement(options, element, struct);
    });

    // if artifact has a cds.valid.key make this the only primary key and
    // add all @cds.valid.from + original primary keys as alternate keys
    // @Core.AlternateKeys: [{ Key: [ { Name: 'slID', Alias: 'slID' }, { Name: 'validFrom', Alias: 'validFrom'} ] }]

    if(validKey.length) {
      let altKeys = [{ Key: [] }];
      forAll(keys, (k, kn) => {
        altKeys[0].Key.push( { Name: kn, Alias: kn } );
        delete k.key;
      });
      validFrom.forEach(e => {
        altKeys[0].Key.push( { Name: e.name, Alias: e.name } );
      });
      if(struct['@Core.AlternateKeys'] === undefined) {
        struct['@Core.AlternateKeys'] = altKeys;
      }      keys = Object.create(null);
      validKey.forEach(e => {
        e.key = true;
        keys[e.name] = e;
      });
    }
    else {
      validFrom.forEach(e => {
        e.key = true;
        keys[e.name] = e;
      });
    }
    setProp(struct, '_EntitySetAttributes', Object.create(null));
    applyAppSpecificLateCsnTransformationOnStructure(options, struct);

    struct['$keys'] = keys;

    // initialize bound actions and functions

    // Attach name to actions and their parameters
    forAll(struct.actions, (a, n) => {
      a.name = n;
      forAll(a.params, (p, n) => {
        p.name = n;
      });
    });
  }

  // Resolve the association type of 'element' in 'struct' by doing the following:
  // - collect the foreign key elements for the target into attribute 'elements'
  function initializeAssociation(struct) {
    foreach(struct.elements, isAssociationOrComposition, element => {
      if (element._ignore)
        return;
      if(!element._target) {
        throw Error('Expect target to be resolved, parent: ' + struct.name + ', assoc: ' + element.name + ', target: ' + element.target);
      }
      // in case this is a forward assoc, store the backlink partneres here, _partnerCsn.length > 1 => error
      setProp(element, '_partnerCsn', []);
      setProp(element._target, '$proxies', []);

      //forward annotations from managed association element to its foreign keys
      if(element.keys && options.isFlatFormat) {
        for(let fk of element.keys) {
          forAll(element, (attr, attrName) => {
            if(attrName[0] == '@')
              struct.elements[fk.$generatedFieldName][attrName] = attr;
          });
        }
      }
    });
  }


  function initializeConstraints(struct) {
    foreach(struct.elements, isAssociationOrComposition, element => {
      if (element._ignore) return;
      setProp(element, '_constraints', getReferentialConstraints(element, signal, warning, options.isFlatFormat));

      // only in V2 we must set the target cardinality of the backlink to the forward:
      if(element._constraints._originAssocCsn && element.cardinality && element.cardinality.max) {
        if(element._constraints._originAssocCsn.cardinality) {
          if(element._constraints._originAssocCsn.cardinality.src) {
            let srcMult = (element._constraints._originAssocCsn.cardinality.src == 1) ? '0..1' : '*';
            let newMult = (element.cardinality.max > 1) ? '*' : '0..1';
            if(options.isV2() && srcMult != newMult) {
              // Association 'E_toF': Multiplicity of Role='E' defined to '*', conflicting with target multiplicity '0..1' from 
              signal(warning`Source cardinality "${element._constraints._originAssocCsn.cardinality.src}" of "${element._constraints._originAssocCsn._parent.name}/${element._constraints._originAssocCsn.name}" conflicts with target cardinality "${element.cardinality.max}" of association "${element._parent.name}/${element.name}"`);
            }
          }
          else {
            element._constraints._originAssocCsn.cardinality.src = element.cardinality.max;
          }
        }
        else {
          element._constraints._originAssocCsn.cardinality = { src: element.cardinality.max };
        }
      }
    });
  }

  // For defining service create proxy target, if original target is outside of defining service
  function redirectDanglingAssociationsToProxyTargets(struct) {

    function whatsMyServiceName(n) {
      return serviceNames.reduce((rc, sn) => n.startsWith(sn + '.') ? rc = sn : rc, undefined);
    }

    let myServiceName = whatsMyServiceName(struct.name);
    // if this artifact is a service member check its associations
    if(myServiceName) {
      foreach(struct.elements, isAssociationOrComposition, element => {
        if (element._ignore || element['@odata.navigable'] === false) {
          return;
        }
        /*
         * Consider everthing @cds.autoexpose: falsy to be a proxy candidate for now
         */
        /*
        if(element._target['@cds.autoexpose'] === false) {
          // :TODO: Also _ignore foreign keys to association?
          foreach(struct.elements,
            e =>
              e['@odata.foreignKey4'] === element.name,
            e => e._ignore = true);
          element._ignore = true;
          signal(info`${element.type.replace('cds.', '')} "${element.name}" excluded, target "${element._target.name}" is annotated '@cds.autoexpose: ${element._target['@cds.autoexpose']}'`,
            ['definitions', struct.name, 'elements', element.name]);
          return;
        }
        */
        // if target is outside defining service, create/reuse proxy
        if(myServiceName !== whatsMyServiceName(element._target.name)) {
          if(options.betaMode && options.isStructFormat && options.isV4() && options.toOdata.odataProxies) {
            // search for eventually existing proxy
            let proxy = element._target.$proxies.filter(p => p.name.startsWith(myServiceName + '.'))[0];
            if(!proxy) {
              let name = myServiceName + '.' + element._target.name.split('.').join('_') + '_proxy';
              proxy = { name, kind: 'entity', $proxy: true, elements: Object.create(null) };
              let hasKeys = false;
              // TODO: If target has parameters, use them as primary key instead of real PK
              foreach(element._target.elements, e => e.key, e => {
                // Omit associations (no navigation properties)
                let ignore = false;
                if (isAssocOrComposition(e.type)) {
                  ignore = true;
                }
                if(isStructured(e)) {
                  exposeStructTypeOf(e, `__${name.replace(/\./g, '_')}_${e.name}`, e.name);
                  /*
                  signal(info`Structured types not yet supported as primary keys of proxy entity type "${name}" for unexposed association target "${element._target.name}"`,
                    ['definitions', struct.name, 'elements', element.name]);
                  */
                }
                if(!ignore) {
                  // clone elements and strip off all annotations
                  proxy.elements[e.name] = cloneCsn(e);
                  Object.keys(proxy.elements[e.name]).forEach(k => {
                    if(k[0] === '@') delete proxy.elements[e.name][k]
                  });
                  hasKeys = true;
                }
              });
              if(!hasKeys) {
                element._ignore = true;
                signal(info`Could not create proxy entity type "${name}" for unexposed association target "${element._target.name}", because target has no primary keys`,
                  ['definitions', struct.name, 'elements', element.name]);
                return;
              }
              // wire up proxy
              if(csn.definitions[name] !== undefined)
                signal(error`Duplicate proxy entity type "${name}" for unexposed association target "${element._target.name}"`,
                ['definitions', struct.name, 'elements', element.name]);
              else {
                signal(info`Created proxy entity type "${name}" for unexposed association target "${element._target.name}"`,
                  ['definitions', struct.name, 'elements', element.name]);
                csn.definitions[name] = proxy;
              }
              element._target.$proxies.push(proxy);
            }
            element._target = proxy;
              // remove referential constraints
            element._constraints.constraints = Object.create(null);
          }
          else {
            element._ignore = true;
            signal(warning`No OData navigation property generated for association "${element.name}", as target "${element._target.name}" is outside any service`,
              ['definitions', struct.name, 'elements', element.name]);
            return;
          }
        }
      });
    }

    // If 'node' exists and has a structured type that is not exposed in 'service', (because the type is
    // anonymous or has a definition outside of 'service'), create an equivalent type in 'service', either
    // using the type's name or (if anonymous) 'artificialName', and make 'node' use that type instead.
    // Complain if there is an error.
    function exposeStructTypeOf(node, artificialName, parentName) {
      if (!node) {
        return;
      }
      if (node.items) {
        exposeStructTypeOf(node.items, artificialName, parentName);
      }

      let elements = (csn.definitions[node.type] || node).elements;
      let isNotInProtNS = node.type && (!node.type.startsWith('cds.') || node.type.startsWith('cds.foundation'));
      let isNotInService = node.type && myServiceName !== whatsMyServiceName(node.type);
      if (elements && !node.type || (isNotInService && isNotInProtNS)) {
        let typeDef = node.type ? csn.definitions[node.type] : /* anonymous type */ node;
        if (typeDef && isStructured(typeDef)) {
          // if type has been exposed already use this type name
          if(typeDef.$odataProxyType) {
            node.type = typeDef.$odataProxyType;
            return;
          } else {
            // expose the type
            let typeId = node.type ? `${artificialName}_${node.type.replace(/\./g, '_')}` : artificialName;
            let type = exposeStructType(typeId, typeDef.elements);
            if(type) {
              // Recurse into elements of 'type' (if any)
              for (let elemName in type.elements) {
                exposeStructTypeOf(type.elements[elemName], `${typeId}_${elemName}`, parentName);
              }
              typeDef.$odataProxyType = node.type = `${myServiceName}.${typeId}`;
            }
          }
        }
      }

      function exposeStructType(typeId, elements) {
        let typeName = `${myServiceName}.${typeId}`;
        // If type already exists, reuse it (complain if not created here)
        let type = csn.definitions[typeName];
        if (type) {
          signal(error`Cannot create type "${typeName}" for "${parentName}" because the name is already used`);
          return undefined;
        }
        // Create type with empty elements
        type = {
          kind: 'type',
          name: typeName,
          elements: Object.create(null),
        };
        setProp(type, '$odataProxyType', typeName);
        // Duplicate the type's elements
        for (let elemName in elements) {
          // !!! DO NOT expose associations for proxies!!!
          let elem = elements[elemName];
          if(!elem.target) {
            type.elements[elemName] = Object.create(null);
            for (let prop in elem)
              type.elements[elemName][prop] = elem[prop];
          }
        }
        csn.definitions[typeName] = type;
        return type;
      }
    }
  }

  function determineEntitySet(struct) {
    // if this is an entity or a view, determine if an entity set is required or not
    // 1) must not be a proxy and not a containee in V4
    // No annos are rendered for non-existing EntitySet targets.
    if(struct.hasEntitySet === undefined) {
      let hasEntitySet = ['entity', 'view'].includes(struct.kind) && !(options.isV4() && edmUtils.isContainee(struct)) && !struct.$proxy;
      setProp(struct, 'hasEntitySet', hasEntitySet);
    }
  }

  // If containment in V4 is active, annotations that would be assigned to the containees
  // entity set are not renderable anymore. In such a case try to reassign the annotations to
  // the containment navigation property.
  // Today only Capabilities.*Restrictions are known to be remapped as there exists a CDS
  // short cut annotation @readonly that gets expanded and can be safely remapped.
  function rewriteContainmentAnnotations(container, containee, assocName) {
    // rectify Restrictions to NavigationRestrictions
    if(options.isV4() && container['@Capabilities.NavigationRestrictions'] === undefined) {
      let navRestr = {
        RestrictedProperties: [
          {
            NavigationProperty: assocName
          }
        ]
      };
      let hasRestrictions = false;
      if(containee['@Capabilities.DeleteRestrictions.Deletable'] !== undefined) {
        navRestr.RestrictedProperties[0].DeleteRestrictions =
          { 'Deletable': containee['@Capabilities.DeleteRestrictions.Deletable'] };
        delete containee['@Capabilities.DeleteRestrictions.Deletable'];
        hasRestrictions = true;
      }
      if(containee['@Capabilities.InsertRestrictions.Insertable'] !== undefined) {
        navRestr.RestrictedProperties[0].InsertRestrictions =
          { 'Insertable': containee['@Capabilities.InsertRestrictions.Insertable'] };
        delete containee['@Capabilities.InsertRestrictions.Insertable'];
        hasRestrictions = true;
      }
      if(containee['@Capabilities.UpdateRestrictions.Updatable'] !== undefined) {
        navRestr.RestrictedProperties[0].UpdateRestrictions =
          { 'Updatable': containee['@Capabilities.UpdateRestrictions.Updatable'] };
        delete containee['@Capabilities.UpdateRestrictions.Updatable'];
        hasRestrictions = true;
      }
      //'@Capabilities.ReadRestrictions.Readable'
      if(containee['@Capabilities.ReadRestrictions.Readable'] !== undefined) {
        navRestr.RestrictedProperties[0].ReadRestrictions =
          { 'Readable': containee['@Capabilities.ReadRestrictions.Readable'] };
        delete containee['@Capabilities.ReadRestrictions.Readable'];
        hasRestrictions = true;
      }
      if(hasRestrictions)
        container['@Capabilities.NavigationRestrictions'] = navRestr;
    }
  }
}




/*
 * Late application specific transformations
 *  At present there are two transformation targets: Structure and Element
 *  These transformations are available today:
 *
 *  Analytical Scenario:
 *    If a structure is annotated with @Aggregation.ApplySupported.PropertyRestrictions
 *    then a number of annotation rewrites are done to this structure and to the
 *    elements of this structure
 *    Also the key properties of all structure elements are removed and a new
 *    artificial key element 'key _ID : String' is inserted at first position of
 *    the elements dictionary
 * 
 * PDM (Personal Data Management)
 *    Planned but not yet implemented annotation rewriting (pending to finalization)
 * /
 
/* eslint max-statements-per-line:off */

function mapAnnotationAssignment(artifact, parent, mappingDictionary)
{
  let props = intersect(Object.keys(mappingDictionary), Object.keys(artifact));
  // now start the substituation
  props.forEach(prop => {
    let [ mapping, value, remove_original ] = mappingDictionary[prop];
    if(mapping instanceof Function)
    {
      mapping(artifact, parent, prop);
    }
    else
    {
      assignAnnotation(artifact, mapping, value || artifact[prop]['='] || artifact[prop]);
    }

    if(remove_original)
      delete artifact[prop];
  });
}

function applyAppSpecificLateCsnTransformationOnElement(options, element, struct)
{
  if(options.isV2())
  {
    if(struct['@Aggregation.ApplySupported.PropertyRestrictions'])
    {
      mapAnnotationAssignment(element, struct, AnalyticalAnnotations());
    }
    mapAnnotationAssignment(element, struct, PDMSemantics());
  }

  // etag requires Core.OptimisticConcurrency to be set in V4 (cap/issues#2641)
  // Oliver Heinrich mentions in the issue that the Okra runtime must be set to a
  // concurrent runtime mode by the caller, if the annotation is added this late,
  // it doesn't appear in the forOData processed CSN, meaning that the
  // runtime cannot set that okra flag (alternatively the runtime has to search
  // for @[odata|cds].etag anntotions...
  if(options.isV4())
  {
    if(element['@odata.etag'] == true || element['@cds.etag'] == true) {
      // don't put element name into collection as per advice from Ralf Handl, as
      // no runtime is interested in the property itself, it is sufficient to mark
      // the entity set.
      assignAnnotation(struct, '@Core.OptimisticConcurrency', 
        (struct['@Core.OptimisticConcurrency'] || [])/*.push(element.name)*/);
    }
  }
  
  // nested functions begin
  function PDMSemantics()
  {
    let dict = Object.create(null);
    /*
    dict['@PDM.xxx1'] = [ '@sap.pdm-semantics' ];
    dict['@PDM.xxx2'] = [ '@sap.pdm-propery' ];
    dict['@PDM.xxx3'] = [ '@sap.pdm-display-sq-no' ];
    dict['@PDM.xxx4'] = [ '@sap.pdm-record-identifier' ];
    dict['@PDM.xxx5'] = [ '@sap.pdm-field-group' ];
    dict['@PDM.xxx6'] = [ '@sap.pdm-mask-find-pattern' ];
    dict['@PDM.xxx7'] = [ '@sap.pdm-mask-replacement-pattern' ];
    dict['@PDM.xxx8'] = [ '@sap.deletable' ];
    dict['@PDM.xxx8'] = [ '@sap.updatable' ];

    // respect flattened anntotation $value
    Object.keys(dict).forEach(k => dict[k+'.$value'] = dict[k]);
    */
    return dict;
  }

  function AnalyticalAnnotations()
  {
    function mapCommonAttributes(element, struct, prop)
    {
      let CommonAttributes = element[prop];
      if(!Array.isArray(CommonAttributes))
        throw 'This is not an array value for @Common.attributes: ' + CommonAttributes;
      let targets = intersect(CommonAttributes, Object.keys(struct.elements));
      targets.forEach(tgt => {
        assignAnnotation(struct.elements[tgt], '@sap.attribute-for', element.name);
      });
    }

    function mapContextDefiningProperties(element, struct, prop)
    {
      let ContextDefiningProperties = element[prop];
      if(!Array.isArray(ContextDefiningProperties))
        throw 'This is not an array value for @Aggregation.ContextDefiningProperties: ' + ContextDefiningProperties;
      if(ContextDefiningProperties.length > 0)
        assignAnnotation(element, '@sap.super-ordinate', ContextDefiningProperties[ContextDefiningProperties.length-1]);
    }

    let dict = Object.create(null);
    //analytics term definition unknown, lower case
    dict['@Analytics.Measure'] = [ '@sap.aggregation-role', 'measure' ];
    dict['@Analytics.Dimension'] = [ '@sap.aggregation-role', 'dimension' ];
    dict['@Semantics.currencyCode'] = [ '@sap.semantics', 'currency-code', true ];
    dict['@Semantics.unitOfMeasure'] = [ '@sap.semantics', 'unit-of-measure', true ];

    dict['@Measures.ISOCurrency'] = [ '@sap.unit' ];
    dict['@Measures.Unit'] = [ '@sap.unit' ];

    dict['@Common.Label'] = [ '@sap.label' ];
    dict['@Common.Text'] = [ '@sap.text' ];
    dict['@Aggregation.ContextDefiningProperties'] = [ mapContextDefiningProperties ];
    dict['@Common.Attributes'] = [ mapCommonAttributes ];

    // respect flattened anntotation $value
    Object.keys(dict).forEach(k => dict[k+'.$value'] = dict[k]);
    return dict;
  }
}

function applyAppSpecificLateCsnTransformationOnStructure(options, struct)
{
  if(options.isV2())
  {
    if(struct['@Aggregation.ApplySupported.PropertyRestrictions'])
    {
      transformAnalyticalModel(struct);
      mapAnnotationAssignment(struct, undefined, AnalyticalAnnotations());
    }
  }

  // nested functions begin
  function transformAnalyticalModel(struct)
  {
    let keyName = 'ID__';
    if(struct == undefined || struct.elements == undefined || struct.elements[keyName] != undefined)
      return;
      
    // remove key prop from elemens, add new key to elements
    let elements = Object.create(null);
    elements[keyName] = { key : true, type : 'cds.String', '@sap.sortable':false, '@sap.filterable':false, '@UI.Hidden': true };
    forAll(struct.elements, (e,n) => 
    { 
      if(e.key) delete e.key;
      elements[n] = e;
    });
    struct.elements = elements;
  }

  function AnalyticalAnnotations()
  {
    function mapFilterRestrictions(struct, parent, prop)
    {
      let stringDict = Object.create(null);
      stringDict['SingleValue'] = 'single-value';
      stringDict['MultiValue'] = 'multi-value';
      stringDict['SingleRange'] = 'interval';

      let filterRestrictions = struct[prop];
      if(!Array.isArray(filterRestrictions))
        throw 'This is not an array value for @Capabilities.FilterRestrictions.FilterExpressionRestrictions: ' + filterRestrictions;
      filterRestrictions.forEach(v => {
        let e = struct.elements[v.Property];
        if(e)
          assignAnnotation(e, '@sap.filter-restriction', stringDict[v.AllowedExpressions]);
      });
    }

    function mapRequiredProperties(struct, parent, prop)
    {
      let requiredProperties = struct[prop];
      if(!Array.isArray(requiredProperties))
        throw 'This is not an array value for @Capabilities.FilterRestrictions.RequiredProperties: ' + requiredProperties;
      let props = intersect(Object.keys(struct.elements), requiredProperties)
      props.forEach(p => {
        assignAnnotation(struct.elements[p], '@sap.required-in-filter', true);
      });
    }

    function mapRequiresFilter(struct, parent, prop)
    {
      let requiresFilter = struct[prop];
      if(requiresFilter)
        assignAnnotation(struct._EntitySetAttributes, '@sap.requires-filter', requiresFilter);
    }

      // Entity Props
    let dict = Object.create(null);
    dict['@Aggregation.ApplySupported.PropertyRestrictions'] = [ '@sap.semantics', 'aggregate' ];
    dict['@Common.Label'] = [ '@sap.label' ];
    dict['@Capabilities.FilterRestrictions.RequiresFilter'] = [ mapRequiresFilter ];
    dict['@Capabilities.FilterRestrictions.RequiredProperties'] = [ mapRequiredProperties ];
    dict['@Capabilities.FilterRestrictions.FilterExpressionRestrictions'] = [ mapFilterRestrictions ];

    // respect flattened anntotation $value
    Object.keys(dict).forEach(k => dict[k+'.$value'] = dict[k]);

    return dict;
  }
}

// Assign but not overwrite annotation
function assignAnnotation(node, name, value) {
  if(value !== undefined &&
      name !== undefined && name[0] === '@' &&
      (node[name] === undefined ||
      node[name] && node[name] === null)) {
    node[name] = value;
  }
}

module.exports = {
  initializeModel,
}
