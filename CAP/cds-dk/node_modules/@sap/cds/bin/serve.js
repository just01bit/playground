module.exports = Object.assign ( serve, {
    options: [ '--service', '--from', '--to', '--at', '--with' ],
    flags: [ '--project', '--projects', '--watch', '--bind', '--in-memory', '--in-memory?', '--mocked', '--with-mocks' ],
    shortcuts: [ '-s', undefined, '-2', '-a', '-w', '-p' ],
    help: `
# SYNOPSIS

    *cds serve* [ <filenames> ] [ <options> ]
    *cds serve* [  <service>  ] [ <options> ]

    Starts http servers which load service definitions from cds models,
    construct service providers, mounted to respective endpoints to serve
    incomming requests.

    If the given argument(s) refers to existing files, an effective model
    is loaded from these files and *all services* from which are served.
    The default is '*' which loads all models from the project.

    If the given argument does not match an existing file, it is used
    as the name of the *single service* to serve.


# OPTIONS


    *-s | --service* <name>  (default: 'all')
    *-f | --from* <model>    (default: '*')
    *-w | --with* <impl>
    *-a | --at* <endpoint>
    *-2 | --to* <protocol>

        Use these options to serve a _single service_ from specified model(s)
        to load service definitions from, the endpoint to bind the service
        to, the protocol (i.e. _fiori_, _odata_, or _rest_) to serve and
        optionally which implementation to use (i.e. a _.js_ file).

    *-p | --project* [<project>]

        Runs _cds serve all_ for the specified project; default: cwd.
        You can use *cds run* as shortcut.

    *--watch* [<project>]

        Like *--project* but starts through _nodemon_ to restart the server
        upon changes in code or models.
        You can use *cds watch* as shortcut, which is equivalent to:
        cds serve --with-mocks --in-memory? --watch --project ...

    *--mocked*

        Use this option to launch a _single service_ for a model you imported
        from an external source, e.g. from an S/4 system, in a mock server.
        In addition to constructing the service provider, this will bootstrap
        a transient _in-memory_ database, filled with tables corresponding
        to the signatures of the service's exposed entities.

    *--with-mocks*

        Use this in combination with the variants serving _multiple services_
        to start in-process mock services for all required services configured
        in _package.json#cds.requires_ which don't have external bindings
        in the current process environmemt.

    *--in-memory[?]*

        Automatically adds a transient in-memory database bootstrapped on
        each (re-)start in the same way *cds deploy* would do based on defaults
        or configuration in _package.json#cds.requires.db_. Add a question
        mark to apply a more defensive variant which respects the configured
        database, if any, and only adds an in-memory db if no persistent one is
        configured.

        Requires a sqlite driver to be installed, e.g. _npm i sqlite3_.

# EXAMPLES

    *cds serve*
    *cds serve* all
    *cds serve* CatalogService *--from* app/
    *cds serve* CatalogService *--from* srv/ *--at* /cats *--to* rest
    *cds serve* all --watch --with-mocks --in-memory?
    *cds run* some/project
    *cds watch* some/project
    *cds watch*

`})


const is_in_memory = o => o && o.credentials && o.credentials.database === ':memory:'
const in_memory_db = { kind:'sqlite', credentials:{database:':memory:'} }
const production = process.env.NODE_ENV === 'production'
const process_cwd = process.cwd() // the original cwd, before subsequent chdir, used in logs
const {existsSync:exists} = require ('fs')
const {resolve} = require ('path')


/**
 * The main function which dispatches into the respective usage variants.
 * @param {string[]} all - project folder, model filenames, or service name
 */
async function serve (all=[], o={}) { // NOSONAR

    // canonicalize options to ease subsequent tasks...
    const [pms] = all // project folder, model filenames, or service name
    if (o.project||o.projects) { o.project = pms; o.service='all'; o.from='*' }
    else if (o.service)        { o.from    = pms }
    else if (o.from)           { o.service = pms }
    else if (exists(pms))      { o.service ='all', o.from = all }
    else                       { o.service = pms,  o.from = '*' }
    if (!o.mocked)             { o.mocked  = o['with-mocks'] }

    // handle --watch and --project
    if (o.watch)  return _watch (o.project,o)  // cds serve --watch <project>
    if (o.project)  process.chdir (o.project)  // cds serve --in <project>

    // get locally installed cds
    const cds = _traced (require('../lib/cds')) // IMPORTANT: never load any @sap/cds modules before the chdir above happened!

    // handle --in-memory resp. --in-memory? (requires cds.env)
    o.in_memory = o['in-memory'] || !production && o['in-memory?'] && !cds.requires.db
    if (o.in_memory)  cds.env.add ({requires: {db: in_memory_db}})
    else o.in_memory = is_in_memory(cds.requires.db)

    // load service bindings when mocking or asked to
    if (o.bind||o.mocked) await cds.service.bindings

    // boostrap server from project-local server.js or from @sap/cds/server.js
    const server_js = _local('server.js') || _local(cds.env.folders.srv,'server.js') || cds.server
    const server = await server_js(o)

    // quit if, after all, there are no services to be served
    if (!cds.service.providers.length)  return cds.error (`No service models found in '${o.from}'`)

    // we are finally done -> signal that to everybody
    const done = ()=>cds.emit('listening', { server, url: `http://localhost:${server.address().port}` })
    server.listening ? done() : server.on('listening',done)

    // add fiori preview links to default index.html
    if (cds.env.features.fiori_preview) require('../lib/utils/app/fiori-preview')

}


/** @type <T>(cds:T) => T */
function _traced (cds) { // NOSONAR

    const path = require('path'), _local = file => path.relative (process_cwd,file)
    const _timer = '\n[cds] - launched in'
    console.time (_timer)
    console.log()

    // print information when model is loaded
    cds.on ('loaded', (model)=>{
        const all = model._sources.map (_local)
        console.log (`[cds] - model loaded from ${all.length} file(s):\n\n  ${all.join('\n  ')}\n`)
    })

    // print information about each connected service
    cds.on ('connect', ({name,options:{credentials}})=>{
        console.log (`[cds] - connect to ${name}`, credentials)
    })

    // print information about each provided service
    cds.on ('serving', ({name,path,$impl}) => {
        const serving = name in cds.env.requires ? 'mocking' : 'serving'
        const details = { at:path }
        if ($impl) details.impl = _local($impl._source)
        console.log (`[cds] - ${serving} ${name}`, details)
    })

    // print info when we are finally on air
    cds.on ('listening', ({url})=>{
        console.timeEnd (_timer)
        console.log ('[cds] - server listening on', {url})
        if (cds.watch || process.stdin.isTTY)  console.log (`[ terminate with ^C ]\n`)
    })

    return cds
}


function _local (...path) {
    const file = resolve(...path)
    if (exists(file)) return require (file)
}


function _watch (project,o) {
    try { return require('@sap/cds-dk/bin/watch')([project],o) }
    catch (e) { if (e.code !== 'MODULE_NOT_FOUND')  throw e }
    console.error (`
    cds run --watch has moved.  Please install '@sap/cds-dk' and use
    'cds watch' instead as follows:

        npm uninstall -g @sap/cds
        npm install   -g @sap/cds-dk

        cds watch
    `)
}

/* eslint no-console:off */
