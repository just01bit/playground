module.exports = Object.assign ( compile, {
  options: [
    '--from', '--service', '--lang', '--for', '--to', '--dest', '--log-level'
  ],
  flags: [
    '--all', '--beta', '--clean', '--min'
  ],
  shortcuts: [
    '-f', '-s', '-l', '-4', '-2', '-o'
  ],
  help: `
# SYNOPSIS

    *cds compile* [<models>] [<options>]

    Compiles the specified models, optionally applying specific processors to
    unfold and generate target outputs using the <options> as explained below.
    Reads from stdin if no <models> are specified.


# OPTIONS
    ${''
        // *-f, --from* <frontend>

        //     use the specified frontend to parse the input. <frontend> can be one of
        //     the built-in parsers like *cdl* or *yaml*
        //     valid node module ids of custom parsers.
    }
    *-s* | *--service* <name> | all

        chooses a specific service in case of models containing multiple ones.
        Specify _all_ to force output for all services.

    *-l* | *--lang* <languages> | all

        localize the model with given <languages>, a comma-separated list
        of language/locale codes or _all_. Localization is carried out before
        all other processors (-4/u) or backends (-2).

    *-4* | *--for* <target>

        apply the specified <processors>, a comma-separated list of either
        built-in ones, accessible through _cds.compile.for_ or valid node
        module ids of custom-provided ones. Example:
        cds compile my-model --for odata

    *-2* | *--to* <backends>

        use the specified <backends>, a comma-separated list of either
        built-in ones like _yaml_,_edmx_,_json_,_xsuaa_
        or valid node module ids of custom backends.

    *-o* | *--dest* <folder>

        writes output to the given folder instead of stdout.

    *-log-level* debug | info | warn | error

        specifies which messages to log; default is *warn*

# EXAMPLES

   *cds* compile model.cds
   *cds* c model.json --to cdl
   *cds* srv -s all -l all -2 edmx -o _out

   Use cds as shell command that reads from stdin and writes to stdout:
   *cat* hy | *cds* -2 sql | *sqlite3* test.db

`})

function compile_all (root='.') {

    const {exec} = require ('child_process')
    const cds = require ('../lib/cds')

    exec(`find ${root} -name *.cds ! -path '*/node_modules/*'`, (_,stdout)=>{
        const all = stdout.split('\n').slice(0,-1)
        const info = `\n/ compiled ${all.length} cds models in`
        console.log (`Compiling ${all.length} cds models found in ${process.cwd()}...\n`)
        console.time (info)
        return Promise.all (all.map (each => cds.load(each)
            .then (()=> console.log (' ',each))
            .catch (()=> console.log (' \x1b[91m', each, '\x1b[0m'))
        )).then (()=>
            console.timeEnd (info)
        )
    })

}

function compile (models, options={}) {

    if (options.all)  return compile_all (models[0])

    const cds = require ('../lib/cds')

    let model, src, _suffix; //> be filled in below
    if (!options.as && !/,/.test(options.to))  options.as = 'str'
    if (options.beta)  options.betaMode = true
    if (typeof models === 'string')  models = [models]

    const messages=[]
    if (cds.env.features.snapi === 'runtime-only') cds.env.features.snapi = false
    if (cds.env.features.snapi)  options.messages = messages
    else  options._messages = messages  // some old apis have issues with options.messages

    if (Array.isArray(models) && models.length > 0) {  // any arguments?
        model = cds.load (models, options)
        src = models[0] .replace (/\.[^.]+$/,'')       //> excluding source file extension, e.g. .cds
    } else if (!process.stdin.isTTY && process.argv[1].endsWith('cds')) {  // else check for stdin
        model = readModelFromStdin()
        src = 'stdin'
    } else { // no args, no stdin
        throw new Error (`You must specify a model to compile.\nRun 'cds c -?' to learn more.`)
    }

    let chain = model.then (m => model=m)

    // add processors for compiling
    if (options.for) for (let each of options.for.split(',')) {
        chain = chain.then (next (processor4 (cds.compile.for, each)))
    }

    // add processors for compiler backends
    if (options.to) for (let each of options.to.split(',')) {
        chain = chain.then (next (processor4 (cds.compile.to, _suffix=each)))
    }

    // add processor for i18n
    if (options.lang) {
        const localize = each => cds.localize (model, lang, each)
        let lang = options.lang.split(',')
        if (lang.length === 1 && options.lang !== '*' && options.lang !== 'all')  lang = lang[0]
        chain = chain.then (next (x => {
            if (isSingle(x)) return localize(x)
            else return function*(){
                for (let [each,o] of x)  yield [ localize(each), o ]
            }()
        }))
    }

    // add output processor
    chain = chain.then (cds.write.to ({
        folder: options.dest,
        file: options.file || src,
        suffix: options.suffix || suffix4(_suffix),
        [options.dest ? 'foreach' : 'log']: options.log || consoleLog
    }))

    // add processor for logging compiler messages and errors
    chain = chain.then (logMessages, handleError)

    // return to run
    return chain


    function logMessages (results, m=messages) {
        if (m.length) require('./utils/cli') .log (m, options)
        return results
    }

    function handleError (e) {
        if (e.errors)  logMessages (e,e.errors)
        else throw e
    }

    function processor4 (head, tail) {
        try {
            let proc = tail.split('.').reduce ((prev,next) => prev[next], head)
            if (proc)  return proc
        } catch(e){/* ignore */}
        throw new Error (`    unknown model processor: ${tail}`)
    }

    function next (proc) {
        return (prev) => function*(){
            if (isSingle(prev))  yield [ proc(prev,options) ]
            else for (let [outer,_outer] of prev) {
                let next = proc (outer, options)
                if (isSingle(next)) yield [ next, _outer ]
                else for (let [inner,_inner] of next) {
                    yield [ inner, Object.assign({},_outer,_inner) ]
                }
            }
        }()
    }
    function isSingle (x) {
        return !(x[Symbol.iterator] && x.next)
    }

    function readModelFromStdin(){
        return new Promise ((_resolved, _error) => {
            let src=""; process.stdin
            .on ('data', chunk => src += chunk)
            .on ('end', ()=> _resolved (src[0] === '{' ? JSON.parse(src) : cds.parse(src)))
            .on ('error', _error)
        })
    }

    function consoleLog(o) {
        if (typeof o === 'string')  return console.log (o)
        // in non-tty cases write a proper JSON string
        if (!process.stdout.isTTY)  return console.log (JSON.stringify(o, null, 2))
        // tty: display formatted object
        return console.dir (o, {colors: true, depth: 111})
    }

    function suffix4 (x) { return x && ({
        edmx: '.xml',
        swgr: '.yml',
        cdl: '.cds',
        ddl: '.sql',
        sql: '.sql',
        edm: '.json'
    }[x] || '.'+x) }

}
/* eslint no-console:0 */
