const cdsc = require('./cdsc'), {_csn4} = require('./parse')
const cds = require ('../cds')
const env = cds.env.cdsc
let _compile = async (...args) => _csn4 (await cdsc.compile(...args))

module.exports = Object.assign (load, {only:get})

/**
 * cds.load reads and compiles one or more cds source files into
 * an effective model, including all resolved imports.
 * @returns a CDS model is CSN format
 */
async function load (files, o, compile=_compile) {
  if (!files || files.length === 0) files = '*'
  const all = this.resolve (files) || _notFound (files)
  const csn = await compile (all, undefined, _options(o))
  return _loaded (csn, o)
}

/**
 * cds.get reads and parses a single file, without resolving imports
 * @returns a CDS model is CSN format
 */
async function get (file, o, compile=_compile) {
  const all = this.resolve (file) || _notFound (file)
  if (all.length > 1) throw new Error(`You can only cds.get a single model`)
  const csn = await compile (all, undefined, {..._options(o),parseOnly:true})
  return _loaded (csn, o)
}

function _options (_o) {
  const o = {..._o, ...env}
  const names = o.names || o.sql_mapping || cds.env.sql.names
  if (names !== 'plain') o.sqlMapping = names
  if (!o.messages) {
    cds.env.features.snapi ? o.messages=[] : o._messages=[]
  }
  return o
}

function _loaded (model, options={}) {
  if (options.clean)  model = require('../alpha/_cleanup-csn') (model)
  if (options.min)  model = require('../alpha/_skip_unused') (model)
  cds.emit ('loaded', model)
  return model
}


function _notFound (file) {
  const e = Object.assign (new Error (`Couldn't find a CDS model for: ${file} in: ${process.cwd()}`), {
      code: 'MODEL_NOT_FOUND', model: file
  })
  Error.captureStackTrace(e,_notFound)
  throw e
}


// adjust for existing/former implementation
if (!cds.env.features.snapi) {
  const compile_new = _compile; _compile = require('./cdsv').compile
  load.new = function (files,o) { return load.call (this, files, o, compile_new) }
}
