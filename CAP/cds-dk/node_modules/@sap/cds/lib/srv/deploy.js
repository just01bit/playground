const cds = require('../cds')
const cwd = process.cwd()
const DEBUG = cds.debug('deploy')
const TRACE = process.env.TRACE && ((...args) => console.log (new Date, ...args))

TRACE && TRACE ('cds.deploy...')

exports = module.exports = function cds_deploy (model,options={}) { return {
  async to (db,o=options) { // NOSONAR

    TRACE && (typeof model === 'string' || Array.isArray(model)) && TRACE ('cds.load:', model)
    if (typeof model === 'string' || Array.isArray(model))  model = await cds.load (model)
    if (o.mocked) exports.include_external_entities_in (model)
    else exports.exclude_external_entities_in (model)

    TRACE && (!db.run) && TRACE ('cds.connect:', db)
    if (!db.run) db = await cds.connect.to (db, undefined, !cds.db)
    if (!db.model) db.model = model

    TRACE && TRACE ('cds.deploy')
    const any = await db.deploy (model, o)
    if (!any)  return

    // fill in initial data...
    const SILENT = o && o.silent || process.env.NODE_ENV === 'test'
    TRACE && TRACE ('init_from_js');   await init_from_js (db,model,SILENT)
    TRACE && TRACE ('init_from_csv');  await init_from_csv (db,model,SILENT)
    TRACE && TRACE ('init_from_json'); await init_from_json (db,model,SILENT)

    const {credentials} = db.options, file = credentials && credentials.database
    if (!SILENT) {
      if (file !== ':memory:')  console.log (`/> successfully deployed to ./${file}\n`)
      else console.log (`/> successfully deployed to sqlite in-memory db\n`)
    }

    TRACE && TRACE ('done')
    return db
  },
  // continue to support cds.deploy() as well...
  then(n,e) { return this.to (cds.db||'db') .then (n,e) },
  catch(e) { return this.to (cds.db||'db') .catch (e) },
}}




const { path, isdir, isfile } = cds.utils
const { promisify } = require('util')
const readdir = promisify (cds.utils.readdir)
const read = promisify (cds.utils.readFile)

exports.include_external_entities_in = function (model) {
  const included = []
  for (let each in model.definitions) {
      const def = model.definitions[each]
      if (def['@cds.persistence.skip'] === true) {
          def['@cds.persistence.skip'] = false
          included.push (each)
      }
  }
  if (included.length > 0) {
    Object.defineProperty(model,'_with-mocks',{value:true})
    if (model._xsn) for (let each of included) {
      const dx = model._xsn.definitions[each]
      dx['@cds.persistence.skip'] = {val:false}
    }
  }
  return model
}

exports.exclude_external_entities_in = function (model) {
  for (let [each,{service=each}] of Object.entries (cds.env.requires)) {
    const prefix = service+'.'
    for (let each in model.definitions) if (each.startsWith(prefix)) {
      model.definitions[each]['@cds.persistence.skip'] = true
    }
  }
}


function init_from_js (db, csn, SILENT) {

  if (!csn._sources)  return
  const folders = new Set([ path.resolve('db'), ...csn._sources.map (path.dirname)])
  const inits = []

  for (let each of folders) {
    const file = isfile (path.resolve(each,'init.js'));  if (!file)  continue
    SILENT || console.log (` > initializing database from ${path.relative(cwd,file)}`)  // eslint-disable-line
    let init = require(file);  if (!init)  continue
    if (!init.then && typeof init === 'function')  inits.push (db.run(()=> init(db)))
    else  inits.push (init)
  }

  return Promise.all (inits)
}

function init_from_csv (db, csn, SILENT) {
  return init_from_ (['data','csv'], _csvs, db, csn, SILENT, (entity, src) => {
    let [ cols, ...rows ] = cds.parse.csv (src)
    return rows && rows[0] && INSERT.into (entity) .columns (cols) .rows (rows)
  });

  function _csvs (filename,_,allFiles) {
    if (filename[0] === '-' || !filename.endsWith ('.csv'))  return false
    if (/_texts\.csv$/.test (filename) && check_lang_file(filename, allFiles)) {
      return false
    }
    return true
  }
}

function init_from_json (db, csn, SILENT) {
  return init_from_ (['data'], _jsons, db, csn, SILENT, (entity, src) => {
      let json = JSON.parse (src)
      return json[0] && INSERT.into (entity) .entries (json)
  });

  function _jsons (filename,_,allFiles) {
    if (filename[0] === '-' || !filename.endsWith ('.json'))  return false
    if (/_texts\.json$/.test (filename) && check_lang_file(filename, allFiles)) {
      return false
    }
    return true
  }
}

function check_lang_file(filename, allFiles) {
  // ignores 'Books_texts.csv/json' if there is any 'Books_texts_LANG.csv/json'
  const basename = path.basename(filename)
  const monoLangFiles = allFiles.filter (file => new RegExp('^'+basename+'_').test (file))
  if (monoLangFiles.length > 0) {
    DEBUG && DEBUG (`ignoring '${filename}' in favor of [${monoLangFiles}]`)  // eslint-disable-line
    return true
  }
  return false
}

async function init_from_ (locations, filter, db, csn, SILENT, INSERT_into) { // NOSONAR

  if (!csn._sources)  return
  const folders = new Set
  for (let model of csn._sources) {
    for (let data of locations) {
      for (let each of [ model+data, model+'/../'+data ]) {
        let folder = path.resolve (each)
        if (isdir (folder))  folders.add(folder)
      }
    }
  }

  if (folders.size === 0) return

  const tx = await db.acquire(), inits=[]
  await tx.begin()
  for (let folder of folders) {
    const files = await readdir (folder)
    for (let each of files.filter (filter)) {
      let name = each.replace(/-/g,'.').slice(0, -path.extname(each).length)
      let entity = _entity4 (name)
      if (!entity) { DEBUG && DEBUG (`warning: ${name} not in model`); continue }
      if (entity['@cds.persistence.skip'] === true) continue
      const file = path.join(folder,each)
      const src = await read (file, 'utf8'); if (!src) continue
      const q = INSERT_into (entity,src); if (!q) continue
      SILENT || console.log (` > filling ${entity.name} from ${path.relative(cwd,file)}`)  // eslint-disable-line
      inits.push (tx.run(q))
    }
  }
  await Promise.all(inits)
  await tx.commit()
  return db.release(tx)

  function _entity4 (name) {
    let entity = csn.definitions [name]
    if (!entity) {
      if (/(.+)_texts_?/.test (name)) { // 'Books_texts', 'Books_texts_de'
        const base = csn.definitions [RegExp.$1]
        return base && _entity4 (base.elements.texts.target)
      }
      else return
    }
    // We also support insert into simple views if they have no projection
    if (entity.query) {
      let {SELECT} = entity.query
      if (SELECT && !SELECT.columns && SELECT.from.ref && SELECT.from.ref.length === 1) {
        if (csn.definitions [SELECT.from.ref[0]])  return entity
      }
    }
    return entity.name ? entity : { name, __proto__:entity }
  }

}
/* eslint no-console: off */
/* global INSERT */
