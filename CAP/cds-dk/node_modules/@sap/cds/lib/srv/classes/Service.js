const cds = require('@sap/cds-reflect') // NOTE: require('../cds') would screw VSCode's IntelliSense


/**
 * The base class for all services, that is local, remote and databases.
 */
exports = module.exports = class Service {

    /**
     * This is the central factory method for Services which also replaces
     * the constructor for all subclasses.
     */
    // eslint-disable-next-line no-unused-vars
    static new (name, model, o) { return new this } // NOSONAR

    /**
     * The default constructor deviates to Service.new of the subclass
     * determined from `Service.classes[kind] || require(kind)`.
     */
    constructor (name, model, o) {
        const kind = o.use || o.kind || o.driver
        const Subclass = Service.registry [kind] || require (kind)
        const srv = Subclass.new (name, model, o)
        if (name && !srv.name) srv.name = name
        if (model && !srv.model) srv.model = model
        return srv
    }

    set model(m) {
        super.model = m && 'definitions' in m ? cds.linked(m) : m
    }

    get tx() { return super.tx = this.transaction } // 2-letter shortcut
    get kind() { return super.kind = this.options.kind }
    get definition() { return super.definition = this.model && this.model.definitions [this.name] }
    get operations() { return super.operations = this._reflect (d => d.kind === 'action' || d.kind === 'function') }
    get entities() { return super.entities = this._reflect (d => d.kind === 'entity') }
    get types() { return super.types = this._reflect (d => !d.kind || d.kind === 'type') }

    onSucceeded (...args) { return this._on ('succeeded', ...args) }
    onFailed (...args) { return this._on ('failed', ...args) }


    _on (succeeded_or_failed, event, entity, handler) {
        if (!handler) [entity,handler] = [undefined,entity]
        return this.before (event,entity, req => req.on(succeeded_or_failed, ()=>{ handler(req) }))
    }

    _reflect (filter) {
        const namespace = this.definition && this.definition.name || this.model && this.model.namespace
        return this.model.childrenOf (namespace, filter)
    }


	/** Service.processEvent should be renamed to .dispatch */
	get dispatch() { return this.processEvent }


    /**
     * Constructs a new subclass of other which inherits all of `Service.prototype`
     * @type <T>(other:T) => typeof Service & other
     */
    static and (other) {
        class third extends other {
            // we need to override the other class's constructor with ours...
            constructor() { return new Service (...arguments) } // NOSONAR
        }
        cds.extend (third.prototype) .with (this.prototype)
        return third
    }

    static set classes(c) {  }
}

// Prepare registry for subclasses
Reflect.defineProperty (exports, 'registry', {value:{}})
