const { ServiceClient } = require ('./classes')
const cds = require('../cds'), {one_model} = cds.env.features

/**
 * Connect to a service as primary datasource, i.e. cds.db.
 */
const connect = module.exports = function cds_connect (options) {
	if (!cds.db)  connect.to (options||'db', undefined, 'primary')
	else if (typeof options === 'object') throw cds.error `You need to disconnect before creating a new primary connection!`
	return cds
}

/**
 * Connect to a specific service, either served locally, with ad-hoc options
 * or with options configured in cds.env.requires.<datasource>.
 * @returns { Promise<ServiceClient> & ServiceClient }
 */
connect.to = (datasource, options, primary = !cds.db && datasource === 'db') => {

	if (typeof datasource === 'object')  [ datasource, options ] = [ undefined, datasource ]

	if (datasource in cds.services) { // already connected?
		if (options && options.kind === 'in-process-messaging') ; else // FIXME: should go away
		if (options) throw cds.error `Attempt to reconnect to '${datasource}' with new options`
		return cds.services [datasource]
	}

	if (datasource === 'db'){
		if (cds.db) return cds.db 	// already connected
	}

	const o = options4 (datasource, options, primary)
	const m = model4(o), model = m && 'then' in m ? undefined : m
	const srv = new ServiceClient (datasource, model, o)
	const ps = promised (srv,m)

	if (datasource)  cds.services [datasource] = ps
	if (primary)  cds.db = cds.services.db = ps

	cds.emit ('connect',ps)
	return ps
}


// Helpers...

function options4 (datasource, _o, primary) { // NOSONAR
	const [, kind, url ] = /^(\w+):(.*)/.exec(datasource) || []
	const conf = cds.requires [kind || datasource || _o && _o.kind]
	const o = { kind, ...conf, ..._o, primary }
	if (!(o.kind = o.use || o.driver || o.kind) && !o.silent) throw cds.error (
		conf ? `Configuration for 'cds.requires.${datasource}' lacks mandatory property 'kind'` :
		datasource ? `Didn't find a configuration for 'cds.requires.${datasource}'` :
		`Provided options object lacks mandatory property 'kind'`
	)
	if (url) o.credentials = { ...o.credentials, url, database:url }
	return o
}

function model4 (o) {
	if (is_csn(o.model)) return o.model
	if (cds.model && one_model) return cds.model
	else return o.model && cds.load(o.model)
}

const is_csn = m => typeof m === 'object' && !Array.isArray(m)

/**
 * Wrap connected services into thenables for loading models asynchronously.
 * Hence supports both of these usages:
 *
 *    const db = await cds.connect.to('sql'); db.run(...)
 *    const db = cds.connect.to('sql'); db.run(...)
 *
 * @param {ServiceClient} srv
 */
function promised (srv, m=srv.model) {

	// No asynchronously loaded model -> return a simple decorator
	if (!m || !m.then) return {__proto__:srv,
		then:(r) => Promise.resolve(r(srv)),
		catch:() => Promise.resolve()
	}
	// Else use a decorator that defers all calls to .on, .run et al
	const promised = {__proto__:srv,
		model: new Proxy (m,{ get:()=> cds.error `Model not yet loaded` }),
		entities:()=> cds.error `Cannot access entities unless model is loaded`,
		run:  	 (..._) => ready.then (()=> srv.run (..._)),
		on: 	 (..._) => ready.then (()=> srv.on (..._)),
		before:  (..._) => ready.then (()=> srv.before (..._)),
		after: 	 (..._) => ready.then (()=> srv.after (..._)),
		foreach: (..._) => ready.then (()=> srv.foreach (..._)),
		stream:  (..._) => ready.then (()=> srv.stream (..._)),
		then: (r,e) => ready.then (()=> r(srv),e),
		catch: (e) => ready.catch (e),
	}
	// When model is loaded remove all deferred operations
	const ready = m.then (csn => {
		delete promised.model
		delete promised.entities
		delete promised.run
		delete promised.on
		delete promised.before
		delete promised.after
		delete promised.foreach
		delete promised.stream
		return srv.model = csn
	})
	return promised
}
