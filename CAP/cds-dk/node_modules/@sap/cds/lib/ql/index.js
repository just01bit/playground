const cds = require('../cds'), {extend} = cds
const lib = require('../srv/@sap/cds-services')
const {inspect} = require('util')

const {BaseStatement} = lib.statements

const Query = extend (BaseStatement) .with (class Query extends BaseStatement {

    /** Turns all queries into Thenables which execute with primary db by default */
    async then(r,e) {
        if ('_promised' in this)  return this._promised.then (r,e)
        const pd = Reflect.getOwnPropertyDescriptor (this._target, '_service')
        const srv = pd ? await cds.connect.to (pd.value.name) : cds.db
        const tx = !this._context ? srv : srv.transaction (this._context)
        const p = tx.run(this) .then (r,e)
        Object.defineProperty (this, '_promised', {value:p})
        return p
    }

    /** Beautifies output in REPL */
    [inspect.custom]() {
        const colors = process.env.CDS_TERM_COLORS !== false
        const cmd = this.constructor.name.toUpperCase()
        return`'{ ${cmd}: `+ inspect (this[cmd], {colors, depth: 22})
            .replace (/^\w*\s/,'')
            .replace(/{ ref: \[([^\]]*)\] }/g, (_,ref) => '{ref:['+ref.slice(1,-1)+']}')
            .replace(/{ val: ([^ ]*) }/g, '{val:$1}')
            .replace(/{ (xpr|ref|val): /g, '{$1:')
        +'}'
    }

    byKey (ID) {
        if (this.SELECT)  this.SELECT.one = true
        if (typeof ID !== 'object') ID={ID}
        return this.where (ID)
    }

    /** @type <S>(s:S) => ( typeof Query & S ) */
    static subclass (subclass) { return subclass }

    static factory (fn, _context) { // NOSONAR
        const factory = (e, ...etc) => {
            const _target = (
                !e ? cds.error (`Expected a query target but received ${e}`) :
                typeof e === 'string' ? { name:e } :
                e.name ? e : //> a linked csn definition
                e.ref ? { name: e.ref[0] } :
                e._entityName ? {__proto__:e, name: e._entityName } :
                e._target || { name: undefined }
                // cds.error (`Expected a string, a query, {ref}, {name} or {_entityName} but received ${e}`)
            )
            // NOTE: DO NOT add || entity.name, as ql.BaseStatement impl does something special for views
            const q = fn (e._entityName || e, ...etc)
            return Object.defineProperty (q, '_target', {value:_target})
        }
        return !_context ? factory : (..._) => {
            return Object.defineProperty (factory(..._), '_context', {value:_context})
        }
    }
})



const Select = Query.subclass (lib.statements.SELECT.from('x').constructor)
const Insert = Query.subclass (lib.statements.INSERT.into('x').constructor)
const Update = Query.subclass (lib.statements.UPDATE('x').constructor)
const Delete = Query.subclass (lib.statements.DELETE.from('x').constructor)

// REVISIT should be:
// const Select = Query.subclass (lib.statements.Select)
// const Insert = Query.subclass (lib.statements.Insert)
// const Update = Query.subclass (lib.statements.Update)
// const Delete = Query.subclass (lib.statements.Delete)



const Select_from = Select.from
const Insert_into = Insert.into
const Update_entity = Update.entity
const Delete_from = Delete.from
const select_columns = Select.prototype.columns
const update_set = Update.prototype.set


class SELECT extends Select {

    static in (_context) {
        const SELECT_from = this.factory (this.from, _context)
        const SELECT_columns_from = (..._) => ({ from:(e) => SELECT_from(e).columns(..._) })
        return extend (SELECT_columns_from) .with ({ from: SELECT_from,
            get distinct(){ return SELECT._('distinct',this) },
            get one(){ return SELECT._('one',this) },
        })
    }

    static _ (one_or_distinct, SELECT=this) {
        const SELECT_ood_from = (..._) => {
            if (is_array(_[0])) return { from:(e) => SELECT_ood_from(e).columns(..._) }
            const q = SELECT.from(..._)
            q.SELECT = { [one_or_distinct]: true, ...q.SELECT }
            return q
        }
        const SELECT_ood = Object.assign ((..._) => Object.assign (SELECT_ood_from(..._), {
            from: (e) => SELECT_ood_from(e) .columns (..._)
        }), { from: SELECT_ood_from })
        Object.defineProperty (SELECT, one_or_distinct, {value:SELECT_ood})
        return SELECT_ood
    }

    static from (e, _key, _projection) {
        if (_key === undefined) return Select_from(e)
        if (is_columns(_key)) return Select_from(e).columns(_key)
        if (is_object(_key)) return Select_from(e).byKey(_key)
        else return Select_from(e).byKey({
            [e.keys ? Object.keys(e.keys)[0] : 'ID']: _key
        }).columns(_projection)
    }

    /** Allows to redirect queries
     * @example
     * req.query.redirectTo ('OtherEntity')
     */
    redirectTo (entity) {
        const q = SELECT.from (entity), {from} = q.SELECT
        Object.assign (q.SELECT, this.SELECT, {from})
        return q
    }

    /** @example
     * SELECT.from('Foo') .columns ((foo)=>{...})
     */
    columns (cols, ...more) {
        if (!cols) return this
        if (typeof cols === 'function')  cols = _projection4 (cols, this.entity)
        if (is_array(cols)) return select_columns.call (this, ...cols)
        else return select_columns.call (this, cols, ...more)
    }

    /** @example
     * SELECT.from(...).expand(...)
     */
    expand (ref,cols, exp='expand') {
        const {SELECT} = this, columns = SELECT.columns || (SELECT.columns=[])
        const col = {ref:ref.split('.'), [exp]: cols ? _projection4(cols) : ['*'] }
        columns.push (col)
        return this
    }

    /** @example
     * SELECT.from(...).inline(...)
     */
    inline (ref,cols) {
        return this.expand (ref,cols,'inline')
    }

    /** @example
     * SELECT.from(...).foreach(...)
     */
    foreach (callback) {
        return this.then (rows => rows.map (callback))
    }

}


class INSERT extends Insert {

    static in (_context) {
        const INSERT_into = this.factory (this.into,_context)
        const INSERT_entries_into = (..._) => ({ into:(e) => INSERT_into(e).entries(..._) })
        return extend (INSERT_entries_into) .with ({ into: INSERT_into })
    }

    static into (e, ...entries) {
        const q = Insert_into(e)
        if (entries.length)  q.entries (...entries)
        return q
    }

}


class UPDATE extends Update {

    static in (_context) {
        const UPDATE_entity = this.factory (this.entity,_context)
        return extend (UPDATE_entity) .with ({ entity: UPDATE_entity })
    }

    static entity (e,_key) {
        const q = Update_entity(e)
        if (_key) {
            if (typeof _key !== 'object')  _key = {ID:_key}
            return q.byKey(_key)
        }
        return q
    }

    /** Add support for UPDATE('Foo').set ( expr | fragments | feather ) */
    set (...args) {  // NOSONAR

        if (typeof args[0] === 'object') return update_set.call (this,...args)
        const cqn = this.UPDATE.data = {}
        if (args.length === 1) for (let each of _data(args[0])) {
            const {xpr:[lhs,op,...rhs]} = cds.parse.expr (each)
            cqn[lhs.ref.join('.')] = _rhs (lhs, op, ...rhs)
        } else for (let i=0; i<args.length; ++i) {
            const [,col,op] = /\s*([\w.]+)\s*([%*+-]?=)/.exec (args[i])
            cqn[col] = _rhs (col, op, {val:args[++i]})
        }
        function _rhs (lhs, op, ...rhs) {
            if (op === '=')  return rhs.length === 1 ? rhs[0] : {xpr:rhs}
            if (op.length === 2 && op[1] === '=')  return {xpr:[ lhs.ref ? lhs : {ref:[lhs]}, op[0], ...rhs ]}
            else throw new Error ('Invalid operator in UPDATE(...).set() expression: '+ op)
        }
        return this
    }

}


class DELETE extends Delete {

    static in (_context) {
        const DELETE_from = this.factory (this.from,_context)
        return extend (DELETE_from) .with ({ from: DELETE_from })
    }

    static from (e,_key) {
        const q = Delete_from(e)
        if (_key) {
            if (typeof _key !== 'object')  _key = {ID:_key}
            return q.byKey(_key)
        }
        return q
    }
}


extend(Select).with(SELECT)
extend(Insert).with(INSERT)
extend(Update).with(UPDATE)
extend(Delete).with(DELETE)



function _data(s) {  // NOSONAR
    let all=[], start=0, scope=0, close=0, stack=[ close ]
    for (let i=0; i<s.length; ++i) {
        const c = s[i]
        if (c === ',' && !scope) {
            all.push(s.slice(start,i))
            start = i+1
        } else if (c === "'") {
            while (i<s.length) {
                if (s[++i] === "'") {
                    if (s[i+1] === "'")  ++i  // NOSONAR
                    else break
                }
            }
        }
        else if (c === '(') { scope++; stack.unshift(close=')') }
        else if (c === '[') { scope++; stack.unshift(close=']') }
        else if (c === '{') { scope++; stack.unshift(close='}') }
        else if (c === close) { scope--; stack.shift(); close = stack[0] }
    }
    all.push (s.slice(start))
    return all
}

/**  */
function _projection4 (x, entity) { /* eslint no-unused-vars: off */ // NOSONAR
    if (is_array(x))  return x.map (c => c.ref ? c : {ref:c.split('.')})
    if (typeof x === 'function') {
        const columns=[]
        x (new Proxy (noop,{
            apply: (_,__,[arg]) => {
                if (arg === '*')  columns.push('*')
            },
            get: (_,p) => {
                let col = {ref:[p]};  columns.push(col)
                return new Proxy (noop,{
                    // handle getters like (foo)=>{ foo.bar.car }
                    get: (_,p,me) => {
                        if (p === 'where')  return pred => { col.where = _predicate4(pred); return me }
                        if (p === 'as')  return alias => { col.as = alias; return me }
                        else { col.ref.push(p); return me }
                    },
                    // handle nested projections e.g. (foo)=>{ foo.bar (b=>{ ... }) }
                    apply: (_,__,[fn,{levels=1}={}]) => {
                        if (/^_\b/.test(fn)) {
                            // inline
                            col.inline = _projection4(fn)
                            // REVISIT: following is a flattening implementation, in case cds.ql does not support .inline
                            // columns.pop() // remove the expanded col
                            // for (let each of _projection4(fn)) { // replace by n inlined ones
                            //     columns.push (col = {...each, ref:[...col.ref,...each.ref]})
                            // }
                        } else {
                            // expand
                            col.expand = _projection4(fn)
                            while (--levels) { // add n-level deep hierarchy expands
                                col.expand.push (col = {...col, expand: [...col.expand] })
                            }
                        }
                    },
                })
            }
        }))
        return columns
    }
    else throw new Error ('invalid second argument for SELECT.from(entity,projection)')
}


/**
 * Helper to create a predicate from a feather object
 */
function _predicate4 (o) {
    const predicates = []
    for (let each in o) {
        predicates.push ('and', {ref:each.split('.')}, '=', {val:o[each]})
    }
    return predicates.slice(1)
}

function disable_cds_run(){
    if (disable_cds_run.once || cds.env.singletenant)  return; else disable_cds_run.once = true
    const disabled = ()=>{ throw new Error (`
    Shortcut srv.run() is only available in plain node programs and disabled
    when running services. Always run queries like that in event handlers:
     srv.on('READ','Foo', (req)=>{
        const tx = cds.transaction(req)
        tx.run (SELECT.from('Foo'))
     }
    `)}
    Object.defineProperty (lib.Service.prototype, 'run', {value:disabled})
}
disable_cds_run.once = true //> REVISIT: switching that off for the time being

const noop = ()=>{}
const is_array = Array.isArray
const is_object = (x) => typeof x === 'object' && !is_array(x)
const is_columns = (x) => typeof x === 'function' || is_array(x)



const cds_ql = (_context) => ({
    get SELECT() { return SELECT.in(_context) },
    get INSERT() { return INSERT.in(_context) },
    get UPDATE() { return UPDATE.in(_context) },
    get DELETE() { return DELETE.in(_context) },
})

module.exports = Object.assign (cds_ql, lib.statements, cds_ql(), {
    connect: (...args) => new lib.Service(...args), // FIXME: for compatibility to double-services messaging implementation only
    disable_cds_run
})
